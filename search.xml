<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>打开FTP server或者wftpd32提示 unknow error 10013</title>
      <link href="/2019/08/28/wftpd32-%E6%89%93%E5%BC%80%E6%8F%90%E7%A4%BAunknow-error-10013/"/>
      <url>/2019/08/28/wftpd32-%E6%89%93%E5%BC%80%E6%8F%90%E7%A4%BAunknow-error-10013/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>近期在进行vxworks的相关环境搭建时打开FTP server总提示unknow error，由于没有详细报错信息或错位编号，打开根目录发现调用的是wftpd32程序。<br><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-42-09.png" alt="wftpd32"><br>后考虑可能是软件版本问题，去官网下载了最新的wftpd323，还是同样的问题，不过有错误编号<br><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-43-07.png" alt="wftpd323"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>经查询，该错误是因为FTP默认使用21号端口，本机可能开启其他FTP服务即会出现此问题，关闭或者修改端口即可。</p><p><code>netstat -aon | findstr &quot;21&quot;</code><br><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-44-08.png" alt="查询21号端口占用情况"></p><p><code>tasklist | findstr &quot;14628&quot;</code><br><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-44-30.png" alt="根据PID查询任务"></p><p>或任务管理器找到对应进程关闭<br><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-45-03.png" alt="显示PID"></p><p><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-45-47.png" alt></p><p><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-45-55.png" alt></p><h1 id="重启ftp"><a href="#重启ftp" class="headerlink" title="重启ftp"></a>重启ftp</h1><p>若后续想重启之前的FTP服务，打开iis重启服务即可；也可把之前的FTP端口改为远大于21，例如20000以上<br><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-47-08.png" alt><br>出现如下报错时，打开服务界面，打开相应服务<br><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-47-23.png" alt></p><p><img src="//night-zhang.github.io/2019/08/28/wftpd32-打开提示unknow-error-10013/2019-08-28-09-47-56.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.experts-exchange.com/questions/27212929/FTP-Server.html" target="_blank" rel="noopener">https://www.experts-exchange.com/questions/27212929/FTP-Server.html</a></p><p><a href="https://jingyan.baidu.com/article/3c48dd34491d47e10be358b8.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/3c48dd34491d47e10be358b8.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用软件清单</title>
      <link href="/2019/08/27/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/08/27/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e8%a3%85%e6%9c%ba%e5%89%8d%e4%b8%8b%e8%bd%bd%e6%9c%80%e6%96%b0">装机前下载最新</a></li><li><a href="#%e8%a3%85%e6%9c%ba%e5%bf%85%e5%a4%87">装机必备</a></li><li><a href="#%e7%bc%96%e7%a8%8b%e5%bf%85%e5%a4%87">编程必备</a></li><li><a href="#%e5%a8%b1%e4%b9%90%e5%bf%85%e5%a4%87">娱乐必备</a></li><li><a href="#%e5%85%b6%e4%bb%96">其他</a></li></ul><p>| 主要防止破解软件丢失，有备份加✔</p><h1 id="装机前下载最新"><a href="#装机前下载最新" class="headerlink" title="装机前下载最新"></a>装机前下载最新</h1><ul><li>qq</li><li>tim</li><li>微信</li><li>qq浏览器</li><li>谷歌</li><li>网易云音乐</li></ul><h1 id="装机必备"><a href="#装机必备" class="headerlink" title="装机必备"></a>装机必备</h1><ul><li>系统相关<ul><li>KMSTools_win10激活神器  ✔</li></ul></li><li>压缩解压<ul><li>bandizip    ✔</li></ul></li><li>搜索<ul><li>everything  ✔</li></ul></li><li>卸载工具<ul><li>uninstall tool  ✔</li></ul></li><li>下载工具<ul><li>迅雷无广告版（迅雷X v10.1.12.400）    ✔</li><li>百度云</li><li>pandownload     ✔</li><li>玩客云</li></ul></li><li>置顶工具<ul><li>top置顶工具     ✔</li></ul></li><li>PDF<ul><li>adobeacrobatXpro破解    ✔</li><li>pdfelement6-pro破解     ✔</li><li>CAJViewer</li></ul></li><li>截图工具<ul><li>snipaste</li></ul></li><li>解锁工具<ul><li>lockhunter解锁文件占用    ✔</li></ul></li></ul><h1 id="编程必备"><a href="#编程必备" class="headerlink" title="编程必备"></a>编程必备</h1><ul><li>工具<ul><li>git</li><li>github desktop</li><li>node</li><li>anaconda</li></ul></li><li>ide<ul><li>visual code</li><li>pycharm</li><li>visual studio</li><li>matlab破解      ✔</li><li>notepad</li><li>dev c++</li></ul></li><li>脑图<ul><li>xmind8破解   ✔</li></ul></li><li>数据库<ul><li>navicat12破解   ✔</li></ul></li><li>正则<ul><li>regester    ✔</li></ul></li><li>shell<ul><li>finalshell      ✔</li><li>MobaXterm_Portable_v12.1       ✔</li></ul></li><li>虚拟机<ul><li>vmware</li></ul></li><li>固件分析<ul><li>IDA_Pro_7.0_Windows     ✔</li></ul></li><li>markdown<ul><li>typora</li></ul></li><li>postman<ul><li>Postman-win64-6.1.4-Setup.exe     ✔</li></ul></li></ul><h1 id="娱乐必备"><a href="#娱乐必备" class="headerlink" title="娱乐必备"></a>娱乐必备</h1><ul><li>音乐<ul><li>网易云</li></ul></li><li>视频<ul><li>qq播放器</li><li>potplayer</li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>AIDA64Business（硬件检测）    ✔</li><li>V2RayW（科学上网）    ✔</li><li>Photoshop+CS6.0（阉割破解版）    ✔</li><li>icloud</li><li>teamview      ✔</li><li>DOSBox&amp;工具包     ✔</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tornado创建项目后build vxworks报错unable to allocate heap, heap_chunk_size 587202560, Win32 error 0</title>
      <link href="/2019/08/23/tornado%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%90%8Ebuild-vxworks%E6%8A%A5%E9%94%99unable-to-allocate-heap-heap-chunk-size-587202560-Win32-error-0/"/>
      <url>/2019/08/23/tornado%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%90%8Ebuild-vxworks%E6%8A%A5%E9%94%99unable-to-allocate-heap-heap-chunk-size-587202560-Win32-error-0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#build%e6%8a%a5%e9%94%99unable-to-allocate-heap">build报错“unable to allocate heap”</a></li><li><a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95">解决方法</a></li><li><a href="#%e5%8e%9f%e5%9b%a0%e5%88%86%e6%9e%90">原因分析</a></li><li><a href="#%e5%8f%82%e8%80%83">参考</a></li></ul><h1 id="build报错“unable-to-allocate-heap”"><a href="#build报错“unable-to-allocate-heap”" class="headerlink" title="build报错“unable to allocate heap”"></a>build报错“unable to allocate heap”</h1><p>按照原帖<a href="https://www.jianshu.com/p/d156809e0e64" target="_blank" rel="noopener">VxWorks+Tornado从听说到入门</a>的相关步骤在win10下，进行到“使用篇、step4、build vxworks”时，会有以下报错</p><pre><code>wtxtcl D:\zjm\VxWorks相关\Tornado2.2\host\src\hutils\configGen.tcl ..\Project0.wpjccpentium -c -g -mcpu=pentium -march=pentium -ansi -nostdlib -fno-builtin -fno-defer-pop - P -xassembler-with-cpp -I.. -ID:\zjm\VxWorks相关\Tornado2.2\target\config\vmware -ID:\zjm\ VxWorks相关\Tornado2.2\target\h      -ID:\zjm\VxWorks相关\Tornado2.2\target\config\comps\src  -ID:\zjm\VxWorks相关\Tornado2.2\target\src\drv     -DCPU=PENTIUM -DTOOL_FAMILY=gnu  -DTOOL=gn u -DPRJ_BUILD   -fvolatile D:\zjm\VxWorks相关\Tornado2.2\target\config\vmware\sysALib.s -o  sysALib.occpentium -c -g -mcpu=pentium -march=pentium -ansi -nostdlib -fno-builtin -fno-defer-pop - I.. -ID:\zjm\VxWorks相关\Tornado2.2\target\config\vmware -ID:\zjm\VxWorks相关\Tornado2.2\t arget\h      -ID:\zjm\VxWorks相关\Tornado2.2\target\config\comps\src -ID:\zjm\VxWorks相关\Tor nado2.2\target\src\drv     -DCPU=PENTIUM -DTOOL_FAMILY=gnu  -DTOOL=gnu -DPRJ_BUILD   -fvolati le D:\zjm\VxWorks相关\Tornado2.2\target\config\vmware\ln97xEnd.c -o ln97xEnd.od:\zjm\VxWorks相关\Tornado2.2\host\x86-win32\lib\gcc-lib\i586-wrs-vxworks\2.9-PentiumIII-0 10221\cc1.exe: *** 2. unable to allocate heap, heap_chunk_size 587202560, Win32 error 0make: *** [ln97xEnd.o] Error 0x1Done.</code></pre><p>看提示是说无法分配堆，似乎是太大了</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>借助visio studio的命令行工具修改cc1.exe的二进制文件</p><p>首先打开命令行工具<img src="//night-zhang.github.io/2019/08/23/tornado创建项目后build-vxworks报错unable-to-allocate-heap-heap-chunk-size-587202560-Win32-error-0/2019-08-23-14-21-43.png" alt></p><p>进入到目录：<code>xxx\Tornado2.2\host\x86-win32\lib\gcc-lib\i586-wrs-vxworks\2.9-PentiumIII-010221</code>依次输入如下命令</p><pre><code class="bash">dumpbin /HEADERS cc1.exeeditbin /STACK:67108864 cc1.exedumpbin /HEADERS cc1plus.exeeditbin /STACK:67108864 cc1plus.exe</code></pre><p>然后再次进行build<img src="//night-zhang.github.io/2019/08/23/tornado创建项目后build-vxworks报错unable-to-allocate-heap-heap-chunk-size-587202560-Win32-error-0/2019-08-23-14-24-45.png" alt></p><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>在从在WindowsXP 32位编译到Windows 7 64位的过程中，发现GCC 2.96为PowerPC编写的cc1.exe程序失败了，在一些编译中也出现了同样的错误。使用VisualStudio调试器附加到cc1.exe并使用Sysinals工具进行监视的调查表明：</p><p>1、当cc1.exe程序成功时，它会产生3个线程。</p><p>2、当cc1.exe程序失败时，第三个CreateThread()调用失败ERROR_NOT_ENOUGH_MEMORY.</p><p>3、运行VisualStudio时报告的cc1.exe图像头dumpbin /HEADERS命令，显示堆栈保留大小为400000000字节。也就是说，创建的每个线程都需要400000000字节的连续虚拟地址空间。</p><p>4、当CreateThread调用失败时ERROR_NOT_ENOUGH_MEMORY，Sysinals VMMAP工具表明，最大空闲虚拟内存区域小于请求的400000000字节堆栈保留大小。</p><p>5、cc1.exe是一个32位进程，它有2GBytes的虚拟地址空间。Windows 7具有ASLR(地址空间布局随机化)，这使得DLL的负载地址被随机化。我认为ASLR实际上正在分割虚拟地址空间，因此在cc1.exe进程的某些调用中，加载DLL使用的虚拟地址不会为线程堆栈留下足够大的空闲区域。和ASLR一样，在Windows 7中，加载到cc1.exe中的DLL比在WindowsXP下加载的DLL多出大约4倍，这可能是问题的原因。</p><p>基于上述调查，VisualStudioeditbin /STACK:67108864程序用于将cc1.exe的堆栈保留大小减小到64兆字节，其中选择64兆字节作为用于C+代码的cc1plus.exe程序的堆栈保留大小。随着堆栈储备大小的减小，ERROR_NOT_ENOUGH_MEMORY错误没有再出现。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/d156809e0e64" target="_blank" rel="noopener">https://www.jianshu.com/p/d156809e0e64</a><br><a href="http://www.babaiye.com/?p=349" target="_blank" rel="noopener">http://www.babaiye.com/?p=349</a><br><a href="https://stackoverflow.com/questions/14840572/win32-error-8-during-ccppc-compile-on-windows-7-x86" target="_blank" rel="noopener">https://stackoverflow.com/questions/14840572/win32-error-8-during-ccppc-compile-on-windows-7-x86</a></p>]]></content>
      
      
      <categories>
          
          <category> Vxworks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vxworks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解说明——究竟什么是Windows句柄</title>
      <link href="/2019/08/16/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AFWindows%E5%8F%A5%E6%9F%84/"/>
      <url>/2019/08/16/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AFWindows%E5%8F%A5%E6%9F%84/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2">写在前面：</a></li><li><a href="#%e8%bf%99%e9%87%8c%e9%9c%80%e8%a6%81%e8%af%b4%e6%98%8e">这里需要说明：</a></li><li><a href="#%e8%ae%a9%e6%88%91%e4%bb%ac%e5%85%88%e7%9c%8b%e5%9b%be%e5%86%8d%e8%a7%a3%e9%87%8a">让我们先看图，再解释。</a></li><li><a href="#%e7%ae%80%e5%8d%95%e8%a7%a3%e9%87%8a">简单解释：</a></li><li><a href="#%e4%b8%8b%e9%9d%a2%e5%85%b3%e4%ba%8e%e5%8f%a5%e6%9f%84%e5%86%8d%e4%ba%a4%e4%bb%a3%e4%b8%80%e4%ba%9b%e5%85%b3%e9%94%ae%e6%80%a7%e7%bb%86%e8%8a%82">下面，关于句柄，再交代一些关键性细节：</a></li><li><a href="#%e5%86%99%e5%9c%a8%e5%90%8e%e9%9d%a2">写在后面：</a></li><li><a href="#%e8%bd%ac%e8%87%aa">转自</a></li></ul><h1 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h1><p>对于“句柄”，在下一直停留在一知半解的认识层面，近日在下学习Windows编程，决定趁此机会将句柄彻底搞清楚。查阅了一些网络上的资料，发现网络上的讲解大概可以分为两类：一种是以比喻、类比的方式说明，这种方法虽然形象易懂，但并没有从原理上、本质上加以揭示，让人仍然想问“为什么？”、“怎么实现？”。另一种是给出源代码，无可厚非，这当然是最本质的说明了，但这样一来，又显得不够直观，初学者理解起来有一定的难度。鉴于此，在下尽微末之能，结合自己的愚见，在两者之间折中，用图解的方式来将原理呈现出来，做到一目了然。</p><h1 id="这里需要说明："><a href="#这里需要说明：" class="headerlink" title="这里需要说明："></a>这里需要说明：</h1><p>1.这里将句柄所能标识的所有东西（如窗口、文件、画笔等）统称为“对象”。</p><p>2.图中一个小横框表示一定大小的内存区域，并不代表一个字节，如标有0X00000AC6的横框表示4个字节。</p><p>3.图解的目的是为了直观易懂，所以不一定与源码完全对应，会有一定的简化。</p><h1 id="让我们先看图，再解释。"><a href="#让我们先看图，再解释。" class="headerlink" title="让我们先看图，再解释。"></a>让我们先看图，再解释。</h1><p><img src="//night-zhang.github.io/2019/08/16/图解说明究竟什么是Windows句柄/2019-08-16-10-14-47.png" alt="程序运行到某时刻时的内存快照"><br><img src="//night-zhang.github.io/2019/08/16/图解说明究竟什么是Windows句柄/2019-08-16-10-15-01.png" alt="程序往后运行到另一时刻时的内存快照"></p><p>其中，图1是程序运行到某时刻时的内存快照，图2是程序往后运行到另一时刻时的内存快照。红色部分标出了两次的变化。</p><h1 id="简单解释："><a href="#简单解释：" class="headerlink" title="简单解释："></a>简单解释：</h1><p>Windows是一个以<strong>虚拟内存</strong>为基础的操作系统，很多时候，进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被换出到外存，当再次需要时，再装入内存。两次装入的地址绝大多数情况下是不一样的。</p><p>也就是说，<strong>同一对象在内存中的地址会变化</strong>。（对于虚拟内存不是很了解的读者，可以参考有关操作系统方面的书籍）那么，程序怎么才能准确地访问到对象呢？为了解决这个问题，Windows引入了句柄。</p><p>系统为每个进程在内存中分配一定的区域，用来存放各个句柄，即一个个32位无符号整型值（32位操作系统中）。每个32位无符号整型值相当于一个指针，指向内存中的另一个区域（我们不妨称之为区域A）。而区域A中存放的正是对象在内存中的地址。当对象在内存中的位置发生变化时，区域A的值被更新，变为当前时刻对象在内存中的地址，而在这个过程中，区域A的位置以及对应句柄的值是不发生变化的。</p><p>这种机制，用一种形象的说法可以表述为：有一个固定的地址（句柄），指向一个固定的位置（区域A），而区域A中的值可以动态地变化，它时刻记录着当前时刻对象在内存中的地址。这样，无论对象的位置在内存中如何变化，只要我们掌握了句柄的值，就可以找到区域A，进而找到该对象。而句柄的值在程序本次运行期间是绝对不变的，我们（即系统）当然可以掌握它。这就是以不变应万变，按图索骥，顺藤摸瓜。</p><p>所以，我们可以这样理解Windows句柄：</p><ul><li>数值上，是一个32位无符号整型值（32位系统下）；</li><li>逻辑上，相当于指针的指针；</li><li>形象理解上，是Windows中各个对象的一个<strong>唯一的、固定不变的ID</strong>；</li><li>作用上，Windows使用句柄来标识诸如窗口、位图、画笔等对象，并通过句柄找到这些对象。</li></ul><h1 id="下面，关于句柄，再交代一些关键性细节："><a href="#下面，关于句柄，再交代一些关键性细节：" class="headerlink" title="下面，关于句柄，再交代一些关键性细节："></a>下面，关于句柄，再交代一些关键性细节：</h1><p>1.所谓“唯一”、“不变”是指在程序的一次运行中。如果本次运行完，关闭程序，再次启动程序运行，那么这次运行中，同一对象的句柄的值和上次运行时比较，一般是不一样的。</p><p>&emsp;&emsp;其实这理解起来也很自然，所谓“一把归一把，这把是这把，那把是那把，两者不相干”（“把”是形象的说法，就像打牌一样，这里指程序的一次运行）。</p><p>2.句柄是对象生成时系统指定的，属性是只读的，程序员不能修改句柄。</p><p>3.不同的系统中，句柄的大小（字节数）是不同的，可以使用sizeof()来计算句柄的大小。</p><p>4.通过句柄，程序员只能调用系统提供的服务（即API调用），不能像使用指针那样，做其它的事。</p><h1 id="写在后面："><a href="#写在后面：" class="headerlink" title="写在后面："></a>写在后面：</h1><p>1.到此为止，有关Windows句柄就简单介绍到这里。需要说明的是，本文是面向初学者的，旨在让读者对句柄有一个完整而清晰的认知，既要避免知其然而不知其所以然的茫然困惑，又要避免深入源码的艰难晦涩。因此，本文并不能做到绝对的直达本质，同时也可能在个别细节上与真实情况稍有出入，但在下认为这并不贻害初学者对句柄的认识。因为对某一知识的认知，从几乎一无所知或是一知半解到“精通”，往往需要更多新知识的补充，短时间内很难达到，在不影响知识的使用的前提下，先把握整体，在逐步深入细节，不失为一个明智的选择。想进一步深入理解Windows句柄的读者，可以看在下的下一篇文章<a href="https://www.cnblogs.com/zpcdbky/p/4656449.html" target="_blank" rel="noopener">《源码剖析——深入Windows句柄本质》</a>。</p><p>2.在下知识有限，理解不深，如有错误纰漏之处，这里再三恳请大家一定要为在下指出。大家的批评指正是在下进步的源泉。</p><h1 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h1><p><a href="https://www.cnblogs.com/zpcdbky/p/4652151.html" target="_blank" rel="noopener">https://www.cnblogs.com/zpcdbky/p/4652151.html</a></p><p>原文的参考：</p><p><a href="http://blog.csdn.net/newjerryj/article/details/4383701" target="_blank" rel="noopener">http://blog.csdn.net/newjerryj/article/details/4383701</a></p><p><a href="http://www.cnblogs.com/yellowyu/archive/2009/06/07/1497910.html" target="_blank" rel="noopener">http://www.cnblogs.com/yellowyu/archive/2009/06/07/1497910.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python常用接收输入方式</title>
      <link href="/2019/08/12/python%E5%B8%B8%E7%94%A8%E6%8E%A5%E6%94%B6%E8%BE%93%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/08/12/python%E5%B8%B8%E7%94%A8%E6%8E%A5%E6%94%B6%E8%BE%93%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1、接收“数组长度和数字数组”"><a href="#1、接收“数组长度和数字数组”" class="headerlink" title="1、接收“数组长度和数字数组”"></a>1、接收“数组长度和数字数组”</h1><p>第一行：数组长度；<br>第二行：数组空格间隔</p><pre><code class="python">n = int(input())arr = input()# python2在使用input时，实际调用的是eval(raw_input(prompt))来获取输入，接收带空格的时候需要用引号括起来# eg: &quot;1 2 3&quot;arr_ = [int(n) for n in arr.split()]...</code></pre><h1 id="2、接收数组长度和逐行输入数组内容"><a href="#2、接收数组长度和逐行输入数组内容" class="headerlink" title="2、接收数组长度和逐行输入数组内容"></a>2、接收数组长度和逐行输入数组内容</h1><p>第一行：数组长度n；<br>第二至n+1行：数组内容</p><pre><code class="python">n = int(input())arr = []for i in range(n):    tmp = int(input())    arr.append(tmp)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo技巧</title>
      <link href="/2019/08/02/hexo%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/08/02/hexo%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a><strong>草稿</strong></h1><pre><code class="shell"> //创建草稿：$ hexo new draft &quot;new draft&quot;//草稿转文章（或手动移动_draft下相关文件至_post）：$ hexo publish [layout] &lt;filename&gt;//强行预览草稿，更改配置文件：render_drafts: true//启动草稿server：$ hexo server --drafts</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字节码介绍</title>
      <link href="/2019/07/31/Python%E5%AD%97%E8%8A%82%E7%A0%81%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/07/31/Python%E5%AD%97%E8%8A%82%E7%A0%81%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e4%ba%86%e8%a7%a3-python-%e5%ad%97%e8%8a%82%e7%a0%81%e6%98%af%e4%bb%80%e4%b9%88python-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e5%ae%83%e6%9d%a5%e6%89%a7%e8%a1%8c%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81%e4%bb%a5%e5%8f%8a%e7%9f%a5%e9%81%93%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e5%b8%ae%e5%88%b0%e4%bd%a0%e7%9a%84">了解 Python 字节码是什么，Python 如何使用它来执行你的代码，以及知道它是如何帮到你的。</a></li><li><a href="#python-%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c">Python 如何工作</a></li><li><a href="#python-%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%86%85%e5%b9%95">Python 虚拟机内幕</a></li><li><a href="#%e8%ae%bf%e9%97%ae%e5%92%8c%e7%90%86%e8%a7%a3-python-%e5%ad%97%e8%8a%82%e7%a0%81">访问和理解 Python 字节码</a></li><li><a href="#%e5%ad%97%e8%8a%82%e7%a0%81%e7%9a%84%e7%94%a8%e5%a4%84">字节码的用处</a></li><li><a href="#%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb">延伸阅读</a></li><li><a href="#%e5%8e%9f%e6%96%87">原文</a></li><li><a href="#%e6%84%9f%e6%83%b3">感想</a></li></ul><h1 id="了解-Python-字节码是什么，Python-如何使用它来执行你的代码，以及知道它是如何帮到你的。"><a href="#了解-Python-字节码是什么，Python-如何使用它来执行你的代码，以及知道它是如何帮到你的。" class="headerlink" title="了解 Python 字节码是什么，Python 如何使用它来执行你的代码，以及知道它是如何帮到你的。"></a>了解 Python 字节码是什么，Python 如何使用它来执行你的代码，以及知道它是如何帮到你的。</h1><p>如果你曾经编写过 Python，或者只是使用过 Python，你或许经常会看到 Python 源代码文件——它们的名字以 .py 结尾。</p><p>你可能还看到过其它类型的文件，比如以 .pyc 结尾的文件，或许你可能听说过它们就是 Python 的 “字节码bytecode” 文件。（在 Python 3 上这些可能不容易看到 —— 因为它们与你的 .py 文件不在同一个目录下，它们在一个叫 <strong>pycache</strong> 的子目录中）</p><p>或者你也听说过，这是节省时间的一种方法，它可以避免每次运行 Python 时去重新解析源代码。</p><p>但是，除了 “噢，原来这就是 Python 字节码” 之外，你还知道这些文件能做什么吗？以及 Python 是如何使用它们的？</p><p>如果你不知道，那你走运了！今天我将带你了解 Python 的字节码是什么，Python 如何使用它去运行你的代码，以及知道它是如何帮助你的。</p><h1 id="Python-如何工作"><a href="#Python-如何工作" class="headerlink" title="Python 如何工作"></a>Python 如何工作</h1><p>Python 经常被介绍为它是一个解释型语言 —— 其中一个原因是在程序运行时，你的源代码被转换成 CPU 的原生指令 —— 但这样的看法只是部分正确。Python 与大多数解释型语言一样，确实是<strong>将源代码编译为一组虚拟机指令</strong>，并且 Python 解释器是针对相应的虚拟机实现的。这种中间格式被称为 “字节码”。</p><p>因此，这些 .pyc 文件是 Python 悄悄留下的，是为了让它们运行的 “更快”，或者是针对你的源代码的 “优化” 版本；它们是你的程序在 Python 虚拟机上运行的字节码指令。</p><p>我们来看一个示例。这里是用 Python 写的经典程序 “Hello, World!”：</p><pre><code class="python">def hello()    print(&quot;Hello, World!&quot;)</code></pre><p>下面是转换后的字节码（转换为人类可读的格式）：</p><pre><code class="python">2           0 LOAD_GLOBAL              0 (print)            2 LOAD_CONST               1 (&#39;Hello, World!&#39;)            4 CALL_FUNCTION            1</code></pre><p>如果你输入那个 hello() 函数，然后使用 CPython 解释器去运行它，那么上述列出的内容就是 Python 所运行的。它看起来可能有点奇怪，因此，我们来深入了解一下它都做了些什么。</p><h1 id="Python-虚拟机内幕"><a href="#Python-虚拟机内幕" class="headerlink" title="Python 虚拟机内幕"></a>Python 虚拟机内幕</h1><p>CPython 使用一个基于栈的虚拟机。也就是说，它完全面向栈数据结构的（你可以 “推入” 一个东西到栈 “顶”，或者，从栈 “顶” 上 “弹出” 一个东西来）。</p><p>CPython 使用三种类型的栈：</p><ul><li><p>调用栈<code>call stack</code>。这是运行 Python 程序的主要结构。它为每个当前活动的函数调用使用了一个东西 —— “帧frame”，栈底是程序的入口点。每个函数调用推送一个新的帧到调用栈，每当函数调用返回后，这个帧被销毁。</p></li><li><p>在每个帧中，有一个计算栈<code>evaluation stack</code> （也称为数据栈<code>data stack</code>）。这个栈就是 Python 函数运行的地方，运行的 Python 代码大多数是由推入到这个栈中的东西组成的，操作它们，然后在返回后销毁它们。</p></li><li><p>在每个帧中，还有一个块栈<code>block stack</code>。它被 Python 用于去跟踪某些类型的控制结构：循环、try / except 块、以及 with 块，全部推入到块栈中，当你退出这些控制结构时，块栈被销毁。这将帮助 Python 了解任意给定时刻哪个块是活动的，比如，一个 continue 或者 break 语句可能影响正确的块。<br>大多数 Python 字节码指令操作的是当前调用栈帧的计算栈，虽然，还有一些指令可以做其它的事情（比如跳转到指定指令，或者操作块栈）。</p></li></ul><p>为了更好地理解，假设我们有一些调用函数的代码，比如这个：<code>my_function(my_variable, 2)</code>。Python 将转换为一系列字节码指令：</p><ul><li>一个 <code>LOAD_NAME</code> 指令去查找函数对象 <code>my_function</code>，然后将它推入到计算栈的顶部</li><li>另一个 <code>LOAD_NAME</code> 指令去查找变量 <code>my_variable</code>，然后将它推入到计算栈的顶部</li><li>一个 <code>LOAD_CONST</code> 指令去推入一个实整数值 2 到计算栈的顶部</li><li>一个 <code>CALL_FUNCTION</code> 指令</li></ul><p>这个 CALL_FUNCTION 指令将有 2 个参数，它表示那个 Python 需要从栈顶弹出两个位置参数；然后函数将在它上面进行调用，并且它也同时被弹出（对于函数涉及的关键字参数，它使用另一个不同的指令 —— CALL_FUNCTION_KW，但使用的操作原则类似，以及第三个指令 —— CALL_FUNCTION_EX，它适用于函数调用涉及到参数使用 * 或 ** 操作符的情况）。一旦 Python 拥有了这些之后，它将在调用栈上分配一个新帧，填充到函数调用的本地变量上，然后，运行那个帧内的 my_function 字节码。运行完成后，这个帧将被调用栈销毁，而在最初的帧内，my_function 的返回值将被推入到计算栈的顶部。</p><h1 id="访问和理解-Python-字节码"><a href="#访问和理解-Python-字节码" class="headerlink" title="访问和理解 Python 字节码"></a>访问和理解 Python 字节码</h1><p>如果你想玩转字节码，那么，Python 标准库中的 dis 模块将对你有非常大的帮助；dis 模块为 Python 字节码提供了一个 “反汇编”，它可以让你更容易地得到一个人类可读的版本，以及查找各种字节码指令。dis 模块的文档 可以让你遍历它的内容，并且提供一个字节码指令能够做什么和有什么样的参数的完整清单。</p><p>例如，获取上面的 <code>hello()</code> 函数的列表，可以在一个 Python 解析器中输入如下内容，然后运行它：</p><pre><code class="python">import disdis.dis(hello)</code></pre><p>函数 dis.dis() 将反汇编一个<strong>函数、方法、类、模块、编译过的 Python 代码对象、或者字符串包含的源代码</strong>，以及显示出一个人类可读的版本。dis 模块中另一个方便的功能是 distb()。你可以给它传递一个 Python 追溯对象，或者在发生预期外情况时调用它，然后它将在发生预期外情况时反汇编调用栈上最顶端的函数，并显示它的字节码，以及插入一个指向到引发意外情况的指令的指针。</p><p>它也可以用于查看 Python 为每个函数构建的编译后的代码对象，因为运行一个函数将会用到这些代码对象的属性。这里有一个查看 <code>hello()</code> 函数的示例：</p><pre><code class="python">&gt;&gt;&gt; hello.__code__&lt;code object hello at 0x104e46930, file &quot;&lt;stdin&gt;&quot;, line 1&gt;&gt;&gt;&gt; hello.__code__.co_consts(None, &#39;Hello, World!&#39;)&gt;&gt;&gt; hello.__code__.co_varnames()&gt;&gt;&gt; hello.__code__.co_names(&#39;print&#39;,)</code></pre><p>代码对象在函数中可以以属性 <strong>code</strong> 来访问，并且携带了一些重要的属性：</p><ul><li><code>co_consts</code> 是存在于函数体内的任意<strong>实数</strong>的元组</li><li><code>co_varnames</code> 是函数体内使用的包含任意本地<strong>变量名字</strong>的元组</li><li><code>co_names</code> 是在函数体内引用的任意<strong>非本地名字</strong>的元组<br>许多字节码指令 —— 尤其是那些推入到栈中的加载值，或者在变量和属性中的存储值 —— 在这些元组中的索引作为它们参数。</li></ul><p>因此，现在我们能够理解 <code>hello()</code> 函数中所列出的字节码：</p><ul><li><code>LOAD_GLOBAL 0</code>：告诉 Python 通过 co_names （它是 print 函数）的索引 0 上的名字去查找它指向的全局对象，然后将它推入到计算栈</li><li><code>LOAD_CONST 1</code>：带入 co_consts 在索引 1 上的字面值，并将它推入（索引 0 上的字面值是 None，它表示在 co_consts 中，因为 Python 函数调用有一个隐式的返回值 None，如果没有显式的返回表达式，就返回这个隐式的值 ）。</li><li><code>CALL_FUNCTION 1</code>：告诉 Python 去调用一个函数；它需要从栈中弹出一个位置参数，然后，新的栈顶将被函数调用。</li></ul><p>“原始的” 字节码 —— 是非人类可读格式的字节 —— 也可以在代码对象上作为 co_code 属性可用。如果你有兴趣尝试手工反汇编一个函数时，你可以从它们的十进制字节值中，使用列出 dis.opname 的方式去查看字节码指令的名字。</p><h1 id="字节码的用处"><a href="#字节码的用处" class="headerlink" title="字节码的用处"></a>字节码的用处</h1><p>现在，你已经了解的足够多了，你可能会想 “OK，我认为它很酷，但是知道这些有什么实际价值呢？”由于对它很好奇，我们去了解它，但是除了好奇之外，Python 字节码在几个方面还是非常有用的。</p><p>首先，理解 Python 的<strong>运行模型</strong>可以帮你更好地理解你的代码。人们都开玩笑说，C 是一种 “可移植汇编器”，你可以很好地猜测出一段 C 代码转换成什么样的机器指令。理解 Python 字节码之后，你在使用 Python 时也具备同样的能力 —— 如果你能预料到你的 Python 源代码将被转换成什么样的字节码，那么你可以知道如何更好地写和优化 Python 源代码。</p><p>第二，理解字节码可以帮你更好地回答有关 Python 的问题。比如，我经常看到一些 Python 新手困惑为什么某些结构比其它结构运行的更快（比如，为什么 {} 比 dict() 快）。知道如何去访问和阅读 Python 字节码将让你很容易回答这样的问题（尝试对比一下： dis.dis(“{}”) 与 dis.dis(“dict()”) 就会明白）。</p><p>最后，理解字节码和 Python 如何运行它，为 Python 程序员不经常使用的一种特定的编程方式提供了有用的视角：面向栈的编程。如果你以前从来没有使用过像 FORTH 或 Fator 这样的面向栈的编程语言，它们可能有些古老，但是，如果你不熟悉这种方法，学习有关 Python 字节码的知识，以及理解面向栈的编程模型是如何工作的，将有助你开拓你的编程视野。</p><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><p>如果你想进一步了解有关 Python 字节码、Python 虚拟机、以及它们是如何工作的更多知识，我推荐如下的这些资源：</p><ul><li>Python 虚拟机内幕，它是 Obi Ike-Nwosu 写的一本免费在线电子书，它深入 Python 解析器，解释了 Python 如何工作的细节。</li><li>一个用 Python 编写的 Python 解析器，它是由 Allison Kaptur 写的一个教程，它是用 Python 构建的 Python 字节码解析器，并且它实现了运行 Python 字节码的全部构件。</li><li>最后，CPython 解析器是一个开源软件，你可以在 GitHub 上阅读它。它在文件 Python/ceval.c 中实现了字节码解析器。这是 Python 3.6.4 发行版中那个文件的链接；字节码指令是由第 1266 行开始的 switch 语句来处理的。</li></ul><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p>转自：<a href="https://linux.cn/article-9816-1.html" target="_blank" rel="noopener">https://linux.cn/article-9816-1.html</a></p><p>英文原文：<a href="https://opensource.com/article/18/4/introduction-python-bytecode" target="_blank" rel="noopener">https://opensource.com/article/18/4/introduction-python-bytecode</a></p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p><img src="//night-zhang.github.io/2019/07/31/Python字节码介绍/2019-07-31-17-13-53.png" alt></p><ul><li>也就是说pvm其实都是用的都是栈，编译成pyc的时候其实是把这些都分配进各个栈，然后执行（解释）字节码的时候再去找相应的栈区吗？</li><li>也就是说：文中没提到的第6行字节码<code>POP_TOP</code>，出栈，而出的栈是一个CALL_FUNCTION,所以他会继续把(‘Hello World’)和(print)一起出栈？然后最后RETURN_VALUE？</li><li>{}比dict()快 是因为{}栈直接调用，dict()多了一个函数的栈调用？<ul><li>有人说：核心思想，dict是全局函数，查找比较慢。不如用常量。类似其他全局函数都可以转成局部的适当提速</li><li>也就是从表现上来说，是因为栈中多了一个CALL_FUNCTION，而实际原因是会去搜一下dict这个函数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中时间类型的互转</title>
      <link href="/2019/07/31/Python%E4%B8%AD%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%92%E8%BD%AC/"/>
      <url>/2019/07/31/Python%E4%B8%AD%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%92%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://mubu.com/doc/f8_o7tVRPk" target="_blank" rel="noopener">https://mubu.com/doc/f8_o7tVRPk</a></p><p><img src="//night-zhang.github.io/2019/07/31/Python中时间类型的互转/2019-07-31-16-10-56.png" alt="关系图"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF入门之西北大学NWUCTF练习(2)re逆向练习</title>
      <link href="/2019/07/31/CTF%E5%85%A5%E9%97%A8%E4%B9%8B%E8%A5%BF%E5%8C%97%E5%A4%A7%E5%AD%A6NWUCTF%E7%BB%83%E4%B9%A0-2/"/>
      <url>/2019/07/31/CTF%E5%85%A5%E9%97%A8%E4%B9%8B%E8%A5%BF%E5%8C%97%E5%A4%A7%E5%AD%A6NWUCTF%E7%BB%83%E4%B9%A0-2/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#re1"><strong>re1</strong></a></li><li><a href="#pyc"><strong>pyc</strong></a></li><li><a href="#lets-learn-c"><strong>Let’s learn C</strong></a></li><li><a href="#crackme"><strong>crackme</strong></a></li><li><a href="#nwu"><strong>nwu</strong></a></li></ul><h1 id="re1"><a href="#re1" class="headerlink" title="re1"></a><strong>re1</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-14-06-23.png" alt="题目"><br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-14-06-55.png" alt="运行结果"><br>看结果是hello world,目测主函数只是打印，答案就藏在里面</p><p>IDA打开，找到main函数，先aHelloWorld入栈，然后call子函数，然后。。。<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-14-08-53.png" alt="main"><br>反正我也不是每句都认识，把子函数，或者数据地址都点点看</p><p>刚开始跳转sub_4011F2发现太乱了，就回来点下一个off_407030，马上找到答案，其他的就不看了。<del>反正也看不懂</del><br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-14-11-26.png" alt="答案"></p><h1 id="pyc"><a href="#pyc" class="headerlink" title="pyc"></a><strong>pyc</strong></h1><p>题目是一个pyc文件，首先对其进行反编译<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-14-23-01.png" alt="反编译"><br>发现很多0和o，本地创建后，以比较常见的名称替换恢复后，代码如下</p><pre><code class="python">#!/usr/bin/env python# encoding: utf-8def bar1():    try:        bar2 = int(raw_input(&#39;please enter your key:&#39;))    except Exception:        None        None        None        bar2 = 1    return bar2def bar3(bar4):    bar5 = 0xD8EA21CE54EAA6F16593CC9D3F9B6AEEB2124692BAD8A1B3A12953B394C9FCA82538529753D0CCA7FBCB90D9708CAFB080852772D1907A62418F27EFE7FB27EFL    bar6 = 0x21FF2254681BD592E13F732612B964DA42A68735FF7D96600E3104CCD366FFA3056FE0A803A5AE51E215A9CD544C29116EF912E7B516781B0A781630BABF68B0L    # pow函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z    if pow(2, bar4, bar5) == bar6:        print &#39;nwuctf{key}&#39;     else:        print &#39;sorry, please try again!&#39;while True:    bar7 = bar1()    bar3(bar7)</code></pre><p>就算运行一下也还是因为太长出错<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-14-29-53.png" alt><br>剩下的就一目了然了嘛<del>不会了</del></p><h1 id="Let’s-learn-C"><a href="#Let’s-learn-C" class="headerlink" title="Let’s learn C"></a><strong>Let’s learn C</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-14-55-14.png" alt="题设"><br>代码复制，格式化后如下</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    FILE *txt;    char rflag[30];    char *tflag = &quot;nxwfxf|EfGCDEfgCdEFgCDeF\x81&quot;;    int i, j;    txt = fopen(&quot;flag.txt&quot;, &quot;r&quot;);    fgets(rflag, 26, txt);    for (i = 0; i &lt; 5; i++)        for (j = 0; j &lt; 5; j++)            rflag[i * 5 + j] = rflag[i * 5 + j] + j;//每位加0到4进行偏移    if (strcmp(tflag, rflag) == 0)//比较        puts(&quot;good!&quot;);    else        puts(&quot;error&quot;);    fclose(txt);    return 0;}</code></pre><p>可以看出代码是从flag.txt中读取答案，然后对每一位进行偏移0到4的偏移量（j的值），也就是说把tflag给减去相应的偏移量（x81即0x81-4=0x7D对应的ASII码，即}）</p><p>首先想着直接在写一份代码，进行循环减偏移量</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    char *tflag = &quot;nxwfxf|EfGCDEfgCdEFgCDeF\x81&quot;;    int i, j;    for (i = 0; i &lt; 5; i++)        for (j = 0; j &lt; 5; j++)            tflag[i * 5 + j] = tflag[i * 5 + j] - j;    printf(&quot;%s&quot;, tflag);    return 0;}</code></pre><p>似乎没有结果，好像是有错，不太知道怎么改，有会的老铁麻烦指点一下</p><p>那就暂时只好手动一个个的恢复：<code>nwuctf{CcCCCCccCcCCcCCcC}</code>，手写了几个才发现，妈的全是c，大小写对应上即可。</p><h1 id="crackme"><a href="#crackme" class="headerlink" title="crackme"></a><strong>crackme</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-15-27-32.png" alt><br>题目一直说是VB6写的，但是不懂VB，查查也无从下手，IDA扔一下也没看出什么来，先跳过吧</p><h1 id="nwu"><a href="#nwu" class="headerlink" title="nwu"></a><strong>nwu</strong></h1><p>提示先扔到IDA里看一下，基本上也看不出来什么<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习-2/2019-07-31-15-45-05.png" alt><br>只能看出来栈区大小是34字节</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF入门之西北大学NWUCTF练习(1)预备知识</title>
      <link href="/2019/07/31/CTF%E5%85%A5%E9%97%A8%E4%B9%8B%E8%A5%BF%E5%8C%97%E5%A4%A7%E5%AD%A6NWUCTF%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/07/31/CTF%E5%85%A5%E9%97%A8%E4%B9%8B%E8%A5%BF%E5%8C%97%E5%A4%A7%E5%AD%A6NWUCTF%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e5%9c%b0%e5%9d%80"><strong>地址</strong></a></li><li><a href="#%e7%ac%ac1%e9%a2%98%e6%ac%a2%e8%bf%8e%e6%9d%a5%e5%88%b0nwuctf"><strong>第1题：欢迎来到<strong>NWU</strong>CTF!</strong></a></li><li><a href="#%e7%ac%ac2%e9%a2%98how-to-get-flag-1"><strong>第2题：How to get flag? (1)</strong></a></li><li><a href="#%e7%ac%ac3%e9%a2%98how-to-get-flag-2"><strong>第3题：How to get flag? (2)</strong></a></li><li><a href="#%e7%ac%ac4%e9%a2%98base64%e6%98%af%e5%95%a5"><strong>第4题：base64是啥</strong></a></li><li><a href="#%e7%ac%ac5%e9%a2%98lets-learn-html"><strong>第5题：Let’s learn html</strong></a></li><li><a href="#%e7%ac%ac6%e9%a2%98lets-learn-javascript"><strong>第6题：Let’s learn javascript</strong></a></li><li><a href="#%e7%ac%ac7%e9%a2%98lets-learn-css"><strong>第7题：Let’s learn CSS</strong></a></li><li><a href="#%e7%ac%ac8%e9%a2%98lets-learn-javascript-d"><strong>第8题：Let’s learn javascript :D</strong></a></li></ul><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a><strong>地址</strong></h1><p><code>nwuctf.nwu.edu.cn</code>，西北大学的ctf练习靶场，个人感觉对0基础初学者还是比较贴心的</p><p>做的时候我们尽量先从预备知识开始做</p><h1 id="第1题：欢迎来到NWUCTF"><a href="#第1题：欢迎来到NWUCTF" class="headerlink" title="第1题：欢迎来到NWUCTF!"></a><strong>第1题：欢迎来到<strong>NWU</strong>CTF!</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-41-02.png" alt="题设"><br>我们直接F12即可找到答案<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-41-32.png" alt="解"><br>答案：<code>nwuctf{fl2_tO_g3T_Yur_f1rst_F1ag}</code></p><h1 id="第2题：How-to-get-flag-1"><a href="#第2题：How-to-get-flag-1" class="headerlink" title="第2题：How to get flag? (1)"></a><strong>第2题：How to get flag? (1)</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-44-01.png" alt="2019-07-31-09-44-01.png"><br>首先题目给了两个学习资料：HTTP请求和url详解，题目又提示输入flag<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-44-40.png" alt><br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-44-55.png" alt><br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-45-38.png" alt><br>直接使用GET请求即可<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-46-38.png" alt></p><h1 id="第3题：How-to-get-flag-2"><a href="#第3题：How-to-get-flag-2" class="headerlink" title="第3题：How to get flag? (2)"></a><strong>第3题：How to get flag? (2)</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-48-26.png" alt><br>直接postman在post请求的body中添加flag参数即可<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-49-07.png" alt></p><h1 id="第4题：base64是啥"><a href="#第4题：base64是啥" class="headerlink" title="第4题：base64是啥"></a><strong>第4题：base64是啥</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-50-51.png" alt="题设"><br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-50-39.png" alt="在线解码"></p><h1 id="第5题：Let’s-learn-html"><a href="#第5题：Let’s-learn-html" class="headerlink" title="第5题：Let’s learn html"></a><strong>第5题：Let’s learn html</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-52-43.png" alt="Let&#39;s learn html"><br>发现怎么输都不对，看提示说细心一点，又推荐HTML表单资料，长度改为6即可<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-55-53.png" alt="改长度为6"><br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-09-56-34.png" alt></p><h1 id="第6题：Let’s-learn-javascript"><a href="#第6题：Let’s-learn-javascript" class="headerlink" title="第6题：Let’s learn javascript"></a><strong>第6题：Let’s learn javascript</strong></h1><p><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-10-19-38.png" alt="Let&#39;s learn javascript"><br>不知道哪里下手QAQ</p><h1 id="第7题：Let’s-learn-CSS"><a href="#第7题：Let’s-learn-CSS" class="headerlink" title="第7题：Let’s learn CSS"></a><strong>第7题：Let’s learn CSS</strong></h1><p>去掉偏移属性即可<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-10-33-09.png" alt="Let&#39;s learn CSS"></p><h1 id="第8题：Let’s-learn-javascript-D"><a href="#第8题：Let’s-learn-javascript-D" class="headerlink" title="第8题：Let’s learn javascript :D"></a><strong>第8题：Let’s learn javascript :D</strong></h1><p>这题又不会。。。<br><img src="//night-zhang.github.io/2019/07/31/CTF入门之西北大学NWUCTF练习/2019-07-31-10-42-42.png" alt="Let&#39;s learn javascript :D"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux鸟哥阅读笔记(2)</title>
      <link href="/2019/07/30/Linux%E9%B8%9F%E5%93%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2019/07/30/Linux%E9%B8%9F%E5%93%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a><strong>目录处理</strong></h1><ul><li>cd：变换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li></ul><h1 id="PATH环境变量"><a href="#PATH环境变量" class="headerlink" title="$PATH环境变量"></a><strong>$PATH环境变量</strong></h1><ul><li><code>echo $PATH</code>  显示环境变量</li><li>内容以 : 分隔</li><li><code>PATH=&quot;${PATH}:...绝对路径...&quot;</code>   添加环境变量</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell命令行快捷键</title>
      <link href="/2019/07/29/shell%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/07/29/shell%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h1><ul><li>ctrl + 方向键左键    光标移动到前一个单词开头</li><li>ctrl + 方向键右键    光标移动到后一个单词结尾</li><li>Alt + f: 按单词右移 (往命令行尾部方向，前移）</li><li>Alt + b: 按单词左移（往命令行首部方向，后移）</li><li>ctrl + a      将光标移动到命令行开头</li><li>ctrl + e      将光标移动到命令行结尾处</li><li>ctrl + f      光标向后移动一个字符，相当于VIM里l（不能使用左右方向键时可以用到）</li><li>ctrl + b      光标向前移动一个字符，相当于VIM里h</li><li>ctrl + p      显示上一条命令（不能使用上下方向键时可以用到）</li><li>ctrl + n      显示下一条命令</li></ul><p><em>关键是按单词移动，其他都可以用上下左右home，end解决</em></p><h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><ul><li>Ctrl + c:     删除整行</li><li>Ctrl + y:     粘贴到光标后</li><li>ctrl + u      剪切光标<strong>前面所有</strong>字符</li><li>ctrl + k      剪切光标<strong>后面所有</strong>字符</li><li>Ctrl + w:     剪切从光标位置到当前<strong>单词起始</strong>位置</li><li>Alt + d:      剪切从光标位置到当前<strong>单词末尾</strong>位置</li></ul><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ul><li>ctrl + r      输入若干字符（关键词），会搜索包含所输入关键词的历史命令。继续按Ctrl+r则会继续向前搜索包含关键词的历史命令。找到目标命令后，可以直接按enter键执行找到的命令。如果还想修改参数则可以按右箭头。</li><li>Ctrl + g:     从Ctrl+r的搜索模式中跳出<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1></li><li>ctrl + l      清屏相当于命令clear</li><li>Ctrl + +      字体放大</li><li>Ctrl + -      字体缩小</li><li>ctrl + s      锁住终端</li><li>ctrl + q      解锁终端</li><li>!!               执行历史命令中的最后一条命令</li><li>!$              显示上一条命令中的最后一个参数，相当于esc + .</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux鸟哥阅读笔记(1)——目录、基础指令</title>
      <link href="/2019/07/29/Linux%E9%B8%9F%E5%93%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/29/Linux%E9%B8%9F%E5%93%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84"><strong>目录结构</strong></a></li><li><a href="#linux%e5%9f%ba%e7%a1%80"><strong>Linux基础</strong></a><ul><li><a href="#tips">tips</a></li><li><a href="#%e5%ad%a6%e4%b9%a0%e6%ad%a5%e9%aa%a4">学习步骤</a></li></ul></li><li><a href="#linux%e6%8c%87%e4%bb%a4"><strong>Linux指令</strong></a><ul><li><a href="#%e5%9f%ba%e7%a1%80%e6%8c%87%e4%bb%a4">基础指令</a></li><li><a href="#%e6%9f%a5%e6%89%be%e7%9b%b8%e5%85%b3%e6%8c%87%e4%bb%a4%e7%94%a8%e6%b3%95">查找相关指令用法</a></li></ul></li><li><a href="#%e5%85%b3%e6%9c%ba%e7%9b%b8%e5%85%b3"><strong>关机相关</strong></a><ul><li><a href="#centos%e7%95%8c%e9%9d%a2%e7%9b%b8%e5%85%b3">CentOS界面相关</a></li></ul></li><li><a href="#%e6%9d%83%e9%99%90%e7%9b%b8%e5%85%b3"><strong>权限相关</strong></a><ul><li><a href="#%e6%9b%b4%e6%94%b9%e6%9d%83%e9%99%90">更改权限</a></li></ul></li></ul><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><strong>目录结构</strong></h1><p><img src="//night-zhang.github.io/2019/07/29/Linux鸟哥阅读笔记/2019-07-30-16-35-17.png" alt="FHS四种交互类型"></p><p><img src="//night-zhang.github.io/2019/07/29/Linux鸟哥阅读笔记/2019-07-30-16-36-30.png" alt="目录树"></p><ul><li><p><code>/</code> （root, 根目录） ：与开机系统有关；</p></li><li><p><code>/bin</code>    可执行文件</p></li><li><p><code>/boot</code>   开机用的文件</p></li><li><p><code>/etc</code>    配置文件</p></li><li><p><code>/lib</code>    函数库</p></li><li><p><code>/opt</code>    第三方软件</p></li><li><p><code>/srv</code>    网络服务所需的数据目录</p></li><li><p><code>/tmp</code>    暂存文件</p></li><li><p><code>/home</code>   使用者主文件夹</p></li><li><p><code>/root</code>   root主文件夹</p></li><li><p><code>/usr</code> （unix software resource） ：与软件安装/执行有关；</p><ul><li><code>/usr/share/doc</code>  存放各个命令的说明文档</li></ul></li><li><p><code>/var</code> （variable） ：与系统运行过程有关。</p><ul><li><code>/var/mail</code> （使用者邮件信箱） </li><li><code>/var/run</code> （程序相关）</li><li><code>/var/spool/news</code> （新闻群组） </li><li><code>/var/lock</code> （程序相关）</li><li><code>/var/log/wtmp</code>  登录的数据记录</li></ul></li></ul><h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a><strong>Linux基础</strong></h1><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>安卓算linux核心的一个分支，专门用来针对手机平板这种arm机器设计的</li><li>学习这些基础知识也是为了让自己能掌握搜索的keyword</li><li>一切皆文件</li><li>/usr算可执行程序及相关的文件摆放目录</li></ul><h2 id="学习步骤"><a href="#学习步骤" class="headerlink" title="学习步骤"></a>学习步骤</h2><ul><li>计算机硬件知识（基本OK）</li><li>指令</li><li>权限、user</li><li>shell、shell script</li><li>网络基础的创建</li><li>架站</li></ul><p>硬件相关</p><ul><li>操作系统也是软件，是通过嵌入硬件的BIOS的调用的</li></ul><h1 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a><strong>Linux指令</strong></h1><h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><table><thead><tr><th align="center">指令</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">显示日期与时间</td></tr><tr><td align="center">cal</td><td align="center">显示日历</td></tr><tr><td align="center">bc</td><td align="center">计算器</td></tr><tr><td align="center">[Ctrl]-c</td><td align="center">中断目前程序</td></tr><tr><td align="center">[shift]+{[PageUP]|[Page Down]}</td><td align="center">在<strong>纯文本</strong>的画面中翻页</td></tr></tbody></table><h2 id="查找相关指令用法"><a href="#查找相关指令用法" class="headerlink" title="查找相关指令用法"></a>查找相关指令用法</h2><p>1、–help</p><p>2、man(manual操作说明)</p><p>3、info的信息是分段的，类似man</p><p>4、<code>/usr/share/doc</code>下查阅</p><h1 id="关机相关"><a href="#关机相关" class="headerlink" title="关机相关"></a><strong>关机相关</strong></h1><ul><li>将数据同步写入硬盘中的指令： sync</li></ul><p>建议多次使用</p><ul><li>惯用的关机指令： shutdown</li></ul><p>加<code>-c</code>可以取消关机</p><ul><li>重新开机，关机： reboot, halt, poweroff</li></ul><h2 id="CentOS界面相关"><a href="#CentOS界面相关" class="headerlink" title="CentOS界面相关"></a>CentOS界面相关</h2><p>Linux默认的情况下会提供六个Terminal来让使用者登陆， 切换的方式为使用：[Ctrl] + [Alt] + [F1]<del>[F6]的组合按钮，系统会将[F1] /</del> [F6]命名为<strong>tty1 ~ tty6</strong>的操作接口环境。tty2/~tty6一开始是不存在的！按下 [ctrl]+[alt]+[F2]，系统才产生出额外的 tty2, tty3。</p><p>启动窗口界面：<code>startx</code></p><h1 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a><strong>权限相关</strong></h1><p>User, Group, Others<br><img src="//night-zhang.github.io/2019/07/29/Linux鸟哥阅读笔记/2019-07-29-15-42-50.png" alt="ls -l"><br>档案类型标志位含义：</p><ul><li>当为[ d ]则是目录，例如上表文件名为“.config”的那一行；</li><li>当为[ - ]则是文件，例如上表文件名为“initial-setup-ks.cfg”那一行；</li><li>若是[ l ]则表示为链接文件（link file） ；</li><li>若是[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备） ；</li><li>若是[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备） 。</li></ul><h2 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h2><ul><li>chgrp ：改变文件所属群组<ul><li>eg:<code>chgrp users foo1.txt</code></li><li>群组相关存放在<code>/etc/groupp</code>内</li></ul></li><li>chown ：改变文件拥有者<ul><li>帐号相关存放在<code>/etc/passwd</code></li></ul></li><li>chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性<ul><li><code>&gt; r:4 &gt; w:2 &gt; x:1</code></li><li><code>&gt; owner = rwx = 4+2+1 = 7 &gt; group = rwx = 4+2+1 = 7 &gt; others= --- = 0+0+0 = 0</code></li><li><code>| chmod | u g o a | +（加入） -（除去） =（设置） | r w x | 文件或目录 |</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim手记</title>
      <link href="/2019/07/29/Vim%E6%89%8B%E8%AE%B0/"/>
      <url>/2019/07/29/Vim%E6%89%8B%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e6%a8%a1%e5%bc%8f"><strong>模式</strong></a><ul><li><a href="#%e6%a8%a1%e5%bc%8f%e5%88%87%e6%8d%a2">模式切换</a></li></ul></li><li><a href="#%e7%a7%bb%e5%8a%a8"><strong>移动</strong></a></li><li><a href="#%e6%93%8d%e4%bd%9c"><strong>操作</strong></a></li><li><a href="#%e6%90%9c%e7%b4%a2"><strong>搜索</strong></a></li></ul><p><img src="//night-zhang.github.io/2019/07/29/Vim手记/2019-07-29-10-07-31.png" alt="vim 键盘图"></p><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a><strong>模式</strong></h1><ul><li>Normal（普通模式）</li><li>Insert（插入模式）</li><li>Visual（可视模式）</li></ul><h2 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h2><p>普通→==插入==</p><table><thead><tr><th align="center">按键</th><th align="center">描述</th><th align="center">助记</th></tr></thead><tbody><tr><td align="center"><code>i</code></td><td align="center">在当前光标字符前插入</td><td align="center">insert</td></tr><tr><td align="center"><code>a</code></td><td align="center">在当前光标字符后插入</td><td align="center">append</td></tr><tr><td align="center"><code>I</code></td><td align="center">在当前行首插入</td><td align="center">Insert</td></tr><tr><td align="center"><code>A</code></td><td align="center">在当前行尾插入</td><td align="center">Append</td></tr><tr><td align="center"><code>o</code></td><td align="center">在下方开一新行，插入</td><td align="center">open</td></tr><tr><td align="center"><code>O</code></td><td align="center">在上方开一新行，插入</td><td align="center">Open</td></tr></tbody></table><p>普通模式切换到==可视模式==，按键就比较单一了，比较常用的是：</p><table><thead><tr><th align="center">按键</th><th align="center">描述</th><th align="center">助记</th></tr></thead><tbody><tr><td align="center"><code>v</code></td><td align="center">选中当前光标字符，并进入可视模式</td><td align="center">visual</td></tr><tr><td align="center"><code>V</code></td><td align="center">不同于小写 <code>v</code>，这时移动光标只会按行选择</td><td align="center">Visual</td></tr><tr><td align="center"><code>&lt;Ctrl-v&gt;</code></td><td align="center">块选择模式，此时移动光标会选择一个矩形块</td><td align="center"></td></tr></tbody></table><p>可视模式切换到输入模式一般有以下几种情况：</p><table><thead><tr><th align="center">按键</th><th align="center">描述</th><th align="center">助记</th></tr></thead><tbody><tr><td align="center"><code>s</code></td><td align="center">==删除==当前已选择的内容，并进入插入模式</td><td align="center"></td></tr><tr><td align="center"><code>c</code></td><td align="center">删除当前已选择的内容，并进入插入模式</td><td align="center">change</td></tr><tr><td align="center"><code>di</code></td><td align="center">删除当前已选择的内容，并进入插入模式</td><td align="center"></td></tr></tbody></table><p>可视模式回到普通模式也有很多方式，比较直接的就是<code>&lt;ESC&gt;</code>，当然，还有其他一些按键：</p><table><thead><tr><th align="center">按键</th><th align="center">描述</th><th align="center">助记</th></tr></thead><tbody><tr><td align="center"><code>y</code></td><td align="center">==复制==当前选择区域，并退出可视模式</td><td align="center">yank</td></tr><tr><td align="center"><code>Y</code></td><td align="center">复制当前选择区域（按行），并退出可视模式</td><td align="center">Yank</td></tr></tbody></table><h1 id="移动"><a href="#移动" class="headerlink" title="移动"></a><strong>移动</strong></h1><ul><li>数字n+移动命令     移动n个位置</li></ul><table><thead><tr><th align="center">按键</th><th align="center">描述</th><th align="center">助记</th></tr></thead><tbody><tr><td align="center"><code>0</code></td><td align="center">跳到==行首==，可以理解为无穷大的<code>h</code></td><td align="center"></td></tr><tr><td align="center"><code>^</code></td><td align="center">跳到行首开始的第一个非空白字符</td><td align="center"></td></tr><tr><td align="center"><code>$</code></td><td align="center">跳到==行尾==，可以理解为无穷大的<code>l</code></td><td align="center"></td></tr><tr><td align="center"><code>gg</code></td><td align="center">跳到==首行==，可以理解为无穷大的<code>k</code></td><td align="center"></td></tr><tr><td align="center"><code>G</code></td><td align="center">跳到==末行==，可以理解为无穷大的<code>j</code></td><td align="center"></td></tr><tr><td align="center"><code>w</code></td><td align="center">跳到下一个词首</td><td align="center">word</td></tr><tr><td align="center"><code>b</code></td><td align="center">跳到上一个词首</td><td align="center">back-word</td></tr><tr><td align="center"><code>e</code></td><td align="center">跳到下一个词尾</td><td align="center">end</td></tr><tr><td align="center"><code>ge</code></td><td align="center">跳到上一个词尾</td><td align="center"></td></tr></tbody></table><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h1><table><thead><tr><th align="center">按键</th><th align="center">描述</th><th align="center">助记</th></tr></thead><tbody><tr><td align="center"><code>c</code></td><td align="center">删除，并进入插入模式</td><td align="center">change</td></tr><tr><td align="center"><code>d</code></td><td align="center">删除</td><td align="center">delete</td></tr><tr><td align="center"><code>y</code></td><td align="center">复制</td><td align="center">yank</td></tr><tr><td align="center"><code>gu</code></td><td align="center">变为小写字母</td><td align="center"></td></tr><tr><td align="center"><code>gU</code></td><td align="center">变为大写字母</td><td align="center"></td></tr><tr><td align="center"><code>g~</code></td><td align="center">颠倒字母的大小写</td><td align="center"></td></tr><tr><td align="center"><code>&gt;</code></td><td align="center">右缩进</td><td align="center"></td></tr><tr><td align="center"><code>&lt;</code></td><td align="center">左缩进</td><td align="center"></td></tr><tr><td align="center"><code>=</code></td><td align="center">自动缩进</td><td align="center"></td></tr></tbody></table><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a><strong>搜索</strong></h1><p>/word   搜索</p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode in Python-28. Implement strStr() 实现strStr()</title>
      <link href="/2019/07/26/LeetCode-in-Python-28-Implement-strStr-%E5%AE%9E%E7%8E%B0strStr/"/>
      <url>/2019/07/26/LeetCode-in-Python-28-Implement-strStr-%E5%AE%9E%E7%8E%B0strStr/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%98%e7%9b%ae">题目</a></li><li><a href="#%e8%a7%a3%e6%b3%951">解法1、</a></li><li><a href="#%e5%87%ba%e5%a4%84">出处</a></li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-28-Implement-strStr-实现strStr/2019-07-26-17-37-05.png" alt="实现strStr"></p><h1 id="解法1、"><a href="#解法1、" class="headerlink" title="解法1、"></a>解法1、</h1><pre><code class="python">class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        for i in range(len(haystack) - len(needle) + 1):            if haystack[i:i+len(needle)] == needle:                return i        return -1</code></pre><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>1、对应题目下<strong>Knife丶</strong>的题解</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode in Python-283. Move Zeros 移动零</title>
      <link href="/2019/07/26/LeetCode-in-Python-283-Move-Zeros-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2019/07/26/LeetCode-in-Python-283-Move-Zeros-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0">题目描述</a></li><li><a href="#%e6%b3%a8%e6%84%8f%e7%82%b9">注意点</a></li><li><a href="#%e8%a7%a3%e6%b3%951%e5%88%a9%e7%94%a8%e4%bd%8d%e7%bd%ae%e6%a0%87%e8%ae%b0%e6%9b%bf%e6%8d%a2%e5%85%83%e7%b4%a0%e5%90%8e%e8%a1%a50">解法1、利用位置标记替换元素后补0</a></li><li><a href="#%e8%a7%a3%e6%b3%952%e5%80%9f%e5%8a%a9filter%e5%92%8cenumerate">解法2、借助filter和enumerate</a></li><li><a href="#%e8%a7%a3%e6%b3%953sort">解法3、sort</a></li><li><a href="#%e5%87%ba%e5%a4%84">出处</a></li></ul><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-283-Move-Zeros-移动零/2019-07-26-17-35-51.png" alt="移动零"></p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>必须在原数组上操作，不能拷贝额外的数组<br>PS：修改nums即可，不必有新的返回值</p><h1 id="解法1、利用位置标记替换元素后补0"><a href="#解法1、利用位置标记替换元素后补0" class="headerlink" title="解法1、利用位置标记替换元素后补0"></a>解法1、利用位置标记替换元素后补0</h1><pre><code class="python">class Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        pos = 0        for i in range(len(nums)):            if nums[i]:                nums[pos] = nums[i]                pos += 1        for i in range(pos, len(nums)):            nums[i] = 0</code></pre><p>在for循环的时候虽然会修改nums的内容，但是长度没变，所以不影响循环判断</p><h1 id="解法2、借助filter和enumerate"><a href="#解法2、借助filter和enumerate" class="headerlink" title="解法2、借助filter和enumerate"></a>解法2、借助filter和enumerate</h1><pre><code class="python">class Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        i = 0        for i, n in enumerate(filter(lambda x: x, nums)):            nums[i] = n        for i in range(i + 1, len(nums)):            nums[i] = 0</code></pre><p>1、enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><p><em>enumerate(sequence, [start=0])<br>sequence – 一个序列、迭代器或其他支持迭代对象。<br>start – 下标起始位置。</em></p><p>2、filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><h1 id="解法3、sort"><a href="#解法3、sort" class="headerlink" title="解法3、sort"></a>解法3、sort</h1><pre><code class="python">class Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        nums.sort(key=bool, reverse=True)</code></pre><p>list.sort( key=None, reverse=False)</p><p>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<br>reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。</p><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>1、<a href="https://www.bilibili.com/video/av50408908" target="_blank" rel="noopener">https://www.bilibili.com/video/av50408908</a><br>2、3、对应题目下<strong>Knife丶</strong>的题解</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode in Python-21. Merge Two Sorted Lists 合并两个有序链表</title>
      <link href="/2019/07/26/LeetCode-in-Python-21-Merge-Two-Sorted-Lists-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/26/LeetCode-in-Python-21-Merge-Two-Sorted-Lists-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%98%e7%9b%ae">题目</a></li><li><a href="#%e8%a7%a3%e6%b3%951">解法1、</a></li><li><a href="#%e8%a7%a3%e6%b3%952">解法2、</a></li><li><a href="#%e5%87%ba%e5%a4%84">出处</a></li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-21-Merge-Two-Sorted-Lists-合并两个有序链表/2019-07-26-17-34-11.png" alt="合并两个有序链表"></p><h1 id="解法1、"><a href="#解法1、" class="headerlink" title="解法1、"></a>解法1、</h1><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        curr = dummy = ListNode(0)        while l1 and l2:            if l1.val &lt; l2.val:                curr.next = l1                l1 = l1.next            else:                curr.next = l2                l2 = l2.next            curr = curr.next        curr.next = l1 or l2        return dummy.nextif __name__ == &quot;__main__&quot;:    l1 = ListNode(1)    l1.next = ListNode(2)    l1.next.next = ListNode(4)    l2 = ListNode(1)    l2.next = ListNode(3)    l2.next.next = ListNode(4)    r = Solution().mergeTwoLists(l1, l2)    while r:        print(r.val)        r = r.next</code></pre><p>1、两个变量指向新链表，curr用来更新链表</p><h1 id="解法2、"><a href="#解法2、" class="headerlink" title="解法2、"></a>解法2、</h1><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        if l1 and l2:            if l1.val &gt; l2.val: l1, l2 = l2, l1            l1.next = self.mergeTwoLists(l1.next, l2)        return l1 or l2</code></pre><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>1、<a href="https://www.bilibili.com/video/av45843264" target="_blank" rel="noopener">https://www.bilibili.com/video/av45843264</a><br>2、对应题目下<strong>Knife丶</strong>的题解</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode in Python-14. Longest Common Prefix 最长公共前缀</title>
      <link href="/2019/07/26/LeetCode-in-Python-14-Longest-Common-Prefix-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>/2019/07/26/LeetCode-in-Python-14-Longest-Common-Prefix-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%98%e7%9b%ae">题目</a></li><li><a href="#%e8%a7%a3%e6%b3%951%e9%80%90%e4%bd%8d%e6%af%94%e8%be%83">解法1、逐位比较</a></li><li><a href="#%e8%a7%a3%e6%b3%952%e5%88%a9%e7%94%a8%e9%9b%86%e5%90%88%e6%80%a7%e8%b4%a8">解法2、利用集合性质</a></li><li><a href="#%e8%a7%a3%e6%b3%953zipsets">解法3、zip+sets</a></li><li><a href="#%e8%a7%a3%e6%b3%954%e5%80%9f%e5%8a%a9os%e6%a8%a1%e5%9d%97%e8%87%aa%e5%b8%a6%e5%87%bd%e6%95%b0">解法4、借助os模块自带函数。。。</a></li><li><a href="#%e5%87%ba%e5%a4%84">出处</a></li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-14-Longest-Common-Prefix-最长公共前缀/2019-07-26-17-30-52.png" alt="最长公共前缀"></p><h1 id="解法1、逐位比较"><a href="#解法1、逐位比较" class="headerlink" title="解法1、逐位比较"></a>解法1、逐位比较</h1><pre><code class="python">class Solution:    def longestCommonPrefix(self, strs):        if not strs:            return &quot;&quot;        for i in range(len(strs[0])):            for string in strs[1:]:                if i &gt;= len(string) or string[i] != strs[0][i]:                    return strs[0][:i]        return strs[0]# 当strs = [&quot;&quot;]时，strs视为存在，所以此处我们直接返回第一个元素，即“”</code></pre><p>以第一个单词作为基准，不同就返回前i位<br>注意第二个单词可能比第一个单词短，防止超出循环范围，先比较<em>i &gt;= len(string)</em></p><h1 id="解法2、利用集合性质"><a href="#解法2、利用集合性质" class="headerlink" title="解法2、利用集合性质"></a>解法2、利用集合性质</h1><pre><code class="python">class Solution:    def longestCommonPrefix(self, strs):        result = &quot;&quot;        i = 0        while True:            try:                sets = set(string[i] for string in strs)                if len(sets) == 1:                    result += sets.pop()                    i += 1                else:                    break            except Exception as e:                break        return result</code></pre><p>1、分别把所有单词的对应位放入集合，若集合长度不为1就返回<br>2、用while True时注意及时跳出，常借助try except</p><h1 id="解法3、zip-sets"><a href="#解法3、zip-sets" class="headerlink" title="解法3、zip+sets"></a>解法3、zip+sets</h1><pre><code class="python">class Solution:    def longestCommonPrefix(self, strs):        r = [len(set(c)) == 1 for c in zip(*strs)] + [0]        return strs[0][:r.index(0)] if strs else &#39;&#39;</code></pre><p>1、zip(<em>)解压，zip(</em>star)的结果（输入：strs = [“flower”, “flow”, “flight”]）<br><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-14-Longest-Common-Prefix-最长公共前缀/2019-07-26-17-31-13.png" alt="zip(*star)"><br>2、因为在python中0==False，此处index(0)结果为2<br><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-14-Longest-Common-Prefix-最长公共前缀/2019-07-26-17-31-22.png" alt><br><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-14-Longest-Common-Prefix-最长公共前缀/2019-07-26-17-31-29.png" alt></p><h1 id="解法4、借助os模块自带函数。。。"><a href="#解法4、借助os模块自带函数。。。" class="headerlink" title="解法4、借助os模块自带函数。。。"></a>解法4、借助os模块自带函数。。。</h1><pre><code class="python">class Solution:    def longestCommonPrefix(self, strs: List[str]) -&gt; str:        return os.path.commonprefix(strs)</code></pre><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>1、2、<a href="https://www.bilibili.com/video/av45842114" target="_blank" rel="noopener">https://www.bilibili.com/video/av45842114</a><br>3、对应题目下<strong>Knife丶</strong>的题解</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode in Python-13. Roman to Integer 罗马数字转整数</title>
      <link href="/2019/07/26/LeetCode-in-Python-13-Roman-to-Integer-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2019/07/26/LeetCode-in-Python-13-Roman-to-Integer-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%98%e7%9b%ae">题目</a></li><li><a href="#%e8%a7%a3%e6%b3%951%e5%ad%97%e5%85%b8map">解法1、字典map</a></li><li><a href="#%e8%a7%a3%e6%b3%952">解法2、</a></li><li><a href="#%e5%87%ba%e5%a4%84">出处</a></li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-13-Roman-to-Integer-罗马数字转整数/2019-07-26-17-28-31.png" alt="罗马数字转整数"><br><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-13-Roman-to-Integer-罗马数字转整数/2019-07-26-17-28-37.png" alt="罗马数字转整数"></p><h1 id="解法1、字典map"><a href="#解法1、字典map" class="headerlink" title="解法1、字典map"></a>解法1、字典map</h1><pre><code class="python">class Solution:    def romanToInt(self, s: str) -&gt; int:        numeral_map = {&quot;I&quot; : 1, &quot;V&quot; : 5, &quot;X&quot; : 10, &quot;L&quot; : 50, &quot;C&quot; : 100, &quot;D&quot; : 500, &quot;M&quot; : 1000}        result = 0        for i in range(len(s)):            if i&gt;0 and numeral_map[s[i]] &gt; numeral_map[s[i-1]]:                result += numeral_map[s[i]] - 2*numeral_map[s[i-1]]            else:                result += numeral_map[s[i]]        return result</code></pre><p>注意对i-1的元素要减两次</p><h1 id="解法2、"><a href="#解法2、" class="headerlink" title="解法2、"></a>解法2、</h1><pre><code>class Solution:    def romanToInt(self, s: str) -&gt; int:        d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}        return sum([d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s)])</code></pre><ul><li>构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值-子串内左边罗马数字代表的数值）</li><li>这样一来，遍历整个s的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值</li><li>举个例子，遍历经过IV的时候先记录I的对应值1再往前移动一步记录IV的值3，加起来正好是IV的真实值4。max函数在这里是为了防止遍历第一个字符的时候出现[-1:0]的情况</li></ul><p>1、列表生成式</p><p>2、dict.get()<br><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-13-Roman-to-Integer-罗马数字转整数/2019-07-26-17-28-50.png" alt="dict.get()"></p><p>3、循环或者切片等希望从0开始执行时，可借助max(i-1, 0)来达成</p><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>1、<a href="https://www.bilibili.com/video/av45841108" target="_blank" rel="noopener">https://www.bilibili.com/video/av45841108</a><br>2、对应题目下<strong>Knife丶</strong>的题解</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode in Python-9. Palindrome Number 回文数</title>
      <link href="/2019/07/26/LeetCode-in-Python-9-Palindrome-Number-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2019/07/26/LeetCode-in-Python-9-Palindrome-Number-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%98%e7%9b%ae">题目</a></li><li><a href="#%e8%a7%a3%e6%b3%951%e8%ae%a1%e7%ae%97%e5%8f%8d%e5%ba%8f%e7%9a%84%e5%80%bc">解法1、计算反序的值</a></li><li><a href="#%e8%a7%a3%e6%b3%952%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%80%86%e5%ba%8f%e6%af%94%e8%be%83">解法2、字符串逆序比较</a></li><li><a href="#%e8%a7%a3%e6%b3%953">解法3、</a></li><li><a href="#%e8%a7%a3%e6%b3%954">解法4、</a></li><li><a href="#%e5%87%ba%e5%a4%84">出处</a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-9-Palindrome-Number-回文数/2019-07-26-17-26-17.png" alt="回文数"></li></ul><h1 id="解法1、计算反序的值"><a href="#解法1、计算反序的值" class="headerlink" title="解法1、计算反序的值"></a>解法1、计算反序的值</h1><pre><code class="python">class Solution:    def isPalindrome(self, x: int) -&gt; bool:        num = 0        a = abs(x)        while(a!=0):            temp = a % 10            num = num * 10 + temp            a = a // 10        if x &gt;= 0 and x == num:            return True        else:            return False</code></pre><h1 id="解法2、字符串逆序比较"><a href="#解法2、字符串逆序比较" class="headerlink" title="解法2、字符串逆序比较"></a>解法2、字符串逆序比较</h1><pre><code class="python">class Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &gt;= 0 and int(str(x)[::-1]) == x:            return True        else:            return False</code></pre><h1 id="解法3、"><a href="#解法3、" class="headerlink" title="解法3、"></a>解法3、</h1><pre><code class="python">class Solution:    def isPalindrome(self, x: int) -&gt; bool:        return str(x) == str(x)[::-1]</code></pre><h1 id="解法4、"><a href="#解法4、" class="headerlink" title="解法4、"></a>解法4、</h1><pre><code class="Python">class Solution:    def isPalindrome(self, x: int) -&gt; bool:        r = list(map(lambda i: int(10**-i * x % 10), range(int(math.log10(x)), -1, -1))) if x &gt; 0 else [0, x]        return r == r[::-1]</code></pre><ul><li>思路是一样的，这里把整数转成了列表而不是字符串</li><li>比如一个整数12321，我想取出百位数可以这么做：12321 * 10^{int(log_{10}12321)} % 10 = 123 % 10 = 3</li></ul><p><img src="https://img-blog.csdnimg.cn/20190517173955999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pPTUIxRTEyMzQ1Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1、map() 会根据提供的函数对指定序列做映射。<br>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><p><em>map(function, iterable, …)<br>function – 函数<br>iterable – 一个或多个序列</em></p><p>2、</p><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>1、<a href="https://www.bilibili.com/video/av45840363" target="_blank" rel="noopener">https://www.bilibili.com/video/av45840363</a><br>3、4、对应题目下<strong>Knife丶</strong>的题解</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode in Python-7. Reverse Integer 整数反转</title>
      <link href="/2019/07/26/LeetCode-in-Python-7-Reverse-Integer-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/07/26/LeetCode-in-Python-7-Reverse-Integer-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%98%e7%9b%ae">题目</a></li><li><a href="#%e8%a7%a3%e6%b3%951%e5%88%a9%e7%94%a8%e6%95%b0%e5%80%bc%e5%8f%8d%e8%bd%ac%e6%95%b0%e5%ad%97">解法1、利用数值反转数字</a></li><li><a href="#%e8%a7%a3%e6%b3%952%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8f%8d%e8%bd%ac">解法2、字符串反转</a></li><li><a href="#%e8%a7%a3%e6%b3%953">解法3、</a></li><li><a href="#%e5%87%ba%e5%a4%84">出处</a></li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-7-Reverse-Integer-整数反转/2019-07-26-17-19-04.png" alt="整数反转"></p><h1 id="解法1、利用数值反转数字"><a href="#解法1、利用数值反转数字" class="headerlink" title="解法1、利用数值反转数字"></a>解法1、利用数值反转数字</h1><pre><code class="python">class Solution:    def reverse(self, x: int) -&gt; int:        num = 0        a = abs(x)        while(a!=0):            temp = a % 10            num = num * 10 + temp            a = a // 10        if x &gt; 0 and num &lt; 2**31:            return num        elif x &lt; 0 and num &lt;= 2**31:            return -num        else:            return 0</code></pre><p>借助temp反转数字</p><h1 id="解法2、字符串反转"><a href="#解法2、字符串反转" class="headerlink" title="解法2、字符串反转"></a>解法2、字符串反转</h1><pre><code class="python">class Solution:    def reverse(self, x: int) -&gt; int:        abs_num = abs(x)        abs_num_ = int(str(abs_num)[::-1])        if abs_num_&lt;-2**31 or abs_num_&gt;2**31-1:            return 0        if x&lt;0:            return -abs_num_        return abs_num_</code></pre><h1 id="解法3、"><a href="#解法3、" class="headerlink" title="解法3、"></a>解法3、</h1><pre><code class="python">class Solution:    def reverse(self, x):        r = x // max(1, abs(x)) * int(str(abs(x))[::-1])        return r if r.bit_length() &lt; 32 or r == -2**31 else 0</code></pre><ul><li>x // max(1, abs(x))意味着 0：x为0， 1：x为正， -1：x为负，相当于被废弃的函数cmp</li><li>[::-1]代表序列反转</li><li>2^31 和 -2^31 的比特数为32，其中正负号占用了一位</li><li>32位整数范围 [−2^31， 2^31 − 1] 中正数范围小一个是因为0的存在<h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1>1、<a href="https://www.bilibili.com/video/av45840031" target="_blank" rel="noopener">https://www.bilibili.com/video/av45840031</a><br>3、对应题目下<strong>Knife丶</strong>的题解</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode技巧</title>
      <link href="/2019/07/26/vscode%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/07/26/vscode%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e6%93%8d%e4%bd%9c%e7%9b%b8%e5%85%b3"><strong>操作相关</strong></a></li><li><a href="#%e6%8f%92%e4%bb%b6"><strong>插件</strong></a><ul><li><a href="#%e4%b8%ad%e6%96%87%e6%89%a9%e5%b1%95">中文扩展</a></li><li><a href="#markdown">MarkDown</a><ul><li><a href="#%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e7%9b%ae%e5%bd%95">自动生成目录</a></li></ul></li><li><a href="#%e7%b2%98%e8%b4%b4%e5%9b%be%e7%89%87">粘贴图片</a></li><li><a href="#%e5%9b%be%e6%a0%87%e6%9b%b4%e6%94%b9">图标更改</a></li><li><a href="#%e8%bf%9c%e7%a8%8b">远程</a></li></ul></li></ul><h1 id="操作相关"><a href="#操作相关" class="headerlink" title="操作相关"></a><strong>操作相关</strong></h1><ul><li><p>禅（全屏）模式：<code>Ctrl+KZ</code>（按两次<code>Esc</code>退出）</p></li><li><p>并排编辑：<code>Ctrl+\</code>            按<code>Ctrl+1</code>、<code>Ctrl+2</code>、<code>Ctrl+3</code>在编辑器之间切换；</p></li><li><p>先将鼠标放在向右分割按钮上，然后按住<code>Alt</code>键，按钮变为向下分割按钮：</p></li><li><p>多光标选择</p><ul><li>任意位置多光标：==Alt==（按住不放） + 鼠标任意位置单击；</li><li>同一列多光标：Ctrl+Alt+↑或者Ctrl+Alt+↓；</li><li>多个单词同时选中：先选中单词，然后按Ctrl+Shift+L；</li><li>列（框选）：按住Shift+Alt并拖动鼠标；</li><li>快速滚动：Alt+滚轮；</li><li>某一行上下移动：Alt+↑或↓；</li><li>收缩/扩展选择：Shift+Alt+←或→；</li><li>修剪尾随空格：Ctrl+K Ctrl+X；</li><li>重命名符号：先选中一个符号，然后按F2；</li><li>智能感知：按Ctrl+Space可手动触发感知；</li></ul></li></ul><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a><strong>插件</strong></h1><h2 id="中文扩展"><a href="#中文扩展" class="headerlink" title="中文扩展"></a>中文扩展</h2><p><strong>Chinese (Simplified) Language Pack for Visual Studio Code</strong></p><h2 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h2><p><strong>Markdown All in One</strong></p><h3 id="自动生成目录"><a href="#自动生成目录" class="headerlink" title="自动生成目录"></a>自动生成目录</h3><ul><li><code>ctrl+shift+p</code></li><li><code>ctoc</code><br><img src="//night-zhang.github.io/2019/07/26/vscode技巧/2019-07-26-17-15-13.png" alt="自动生成目录"></li></ul><h2 id="粘贴图片"><a href="#粘贴图片" class="headerlink" title="粘贴图片"></a>粘贴图片</h2><p><strong>Paste Image</strong></p><p>配合Markdown+hexo使用：文件→首选项→设置→json格式→settings.json中添加如下配置</p><pre><code class="&quot;pasteImage.path&quot;:">    &quot;pasteImage.insertPattern&quot;: &quot;![${imageFileName}](${imageFilePath})&quot;,</code></pre><p>快捷键:<code>ctrl + alt + v</code></p><h2 id="图标更改"><a href="#图标更改" class="headerlink" title="图标更改"></a>图标更改</h2><p><strong>vscode-icons</strong></p><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><p><strong>Remote - SSH</strong></p><p>用起来要输入好多次密码比较麻烦，但是连上之后还是很好用的，能直接编辑服务器上的文件，甚至直接安装开发包等</p>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode in Python-1. Two Sum 两数之和</title>
      <link href="/2019/07/26/LeetCode-in-Python-1-Two-Sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/07/26/LeetCode-in-Python-1-Two-Sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0">题目描述</a></li><li><a href="#%e8%a7%a3%e6%b3%951%e5%88%87%e7%89%87%e5%90%8e%e6%9f%a5%e6%89%be">解法1、切片后查找</a></li><li><a href="#%e8%a7%a3%e6%b3%952hash%e5%ad%97%e5%85%b8">解法2、hash字典</a></li><li><a href="#%e8%a7%a3%e6%b3%953%e5%90%8c2">解法3、同2</a></li><li><a href="#%e5%87%ba%e5%a4%84">出处</a></li></ul><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="//night-zhang.github.io/2019/07/26/LeetCode-in-Python-1-Two-Sum-两数之和/2019-07-26-16-57-41.png" alt="两数之和"></p><h1 id="解法1、切片后查找"><a href="#解法1、切片后查找" class="headerlink" title="解法1、切片后查找"></a>解法1、切片后查找</h1><pre><code class="python">class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        for i in nums:            j = target - i            start_index = nums.index(i)            next_index = start_index + 1            temp_nums = nums[next_index:]            if j in temp_nums:                return [nums.index(i), next_index + temp_nums.index(j)]</code></pre><p>注意返回值index的转换</p><h1 id="解法2、hash字典"><a href="#解法2、hash字典" class="headerlink" title="解法2、hash字典"></a>解法2、hash字典</h1><pre><code class="python">class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        dict = {}        for i in range(len(nums)):            if target - nums[i] not in dict:                dict[nums[i]] = i            else:                return [dict[target-nums[i]], i]</code></pre><h1 id="解法3、同2"><a href="#解法3、同2" class="headerlink" title="解法3、同2"></a>解法3、同2</h1><pre><code class="python">class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        dict = {}        for i, num in enumerate(nums):            if target - num in dict:                return [dict[target-num], i]            dict[num] = i</code></pre><p>借助枚举函数，方法同2</p><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>1、2、<a href="https://www.bilibili.com/video/av45727557" target="_blank" rel="noopener">https://www.bilibili.com/video/av45727557</a></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简介</title>
      <link href="/2019/07/26/Linux%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/07/26/Linux%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>对于任何一个研发人员来说，Linux是最强大的操作系统，没有之一！为什么这么说呢，原因有下：</p><ul><li>高效： 简单粗暴有效的命令可以高效的完成很多的日常开发工作</li><li>稳定：Linux运行的稳定性能用来作后台服务器再好不过了</li><li>安全：Linux开源，由很多的开发者共同维护，所以可利用漏洞少之又少</li><li>开放：Linux源码开放</li><li>多用户：真正的可以多用户同时工作</li></ul><p>那么这么强大的一个系统因何而来呢？</p><h2 id="1-GNU-Linux的诞生"><a href="#1-GNU-Linux的诞生" class="headerlink" title="1.GNU/Linux的诞生"></a>1.GNU/Linux的诞生</h2><p>1969年AT&amp;T（美国贝尔实验室）有两个人——<strong>Ken，Dennis</strong>为了适配他们的游戏而研发出了<strong>Unix操作系统</strong>，并且抛弃了汇编，顺便发明了<strong>C语言</strong>，用C完成了整个操作系统，而Unix就是这个话题中的万恶之源~</p><p>其实Unix是开源免费的，因为它只是单机版，没有太大的作用，一段时间后在UC Berkeley诞生出了伟大的TCP/IP协议，使得所有的计算机都可以很好地连通，Unix演变成了BSD，以至于后来的FreeBSD，NetBSD，MacOS，iOS等等……</p><p>然而别忘了，这一切的起源是Unix，当然不可能看着BSD就这么火，Unix开始收费了，对于公司而言，收费就收费呗，无非成本价有点高，然而别忘了还有我们这群苦逼的学生，又想学习使用Unix，又买不起Unix，所以美国一个计算机科学教授Andrew Tnanebaum根据Unix写出了<strong>Minix</strong>操作系统用来教学，青出于蓝而胜于蓝，1991年美国大二学生<strong>Linus Torvalds</strong>觉得Minix不太行，所以自己写了一个<strong>Linux内核</strong>，然而它再强大，也只是一个内核~</p><p>凑巧的是，在那个年代<strong>GNU</strong>（GNU is Not Uinx）也是一个致力于自由的类unix操作系统，它发展了几乎内核以外的所有软件，并且创建了通用软件许可证<strong>GPL</strong>（General Public License） —— 免费得到源码永久使用权、可以任意修改、但是有义务公开修改后的代码~<br>于是乎，Linux和GNU一拍即合，天造地设的一对就这样诞生了，强强联手，演变成现在最强大的操作系统 —— <strong>GNU/Linux</strong>。</p><p><img src="//night-zhang.github.io/2019/07/26/Linux简介/2019-07-26-16-47-45.png" alt="2019-07-26-16-47-45.png"></p><h2 id="2-GNU-Linux衍生的发行版"><a href="#2-GNU-Linux衍生的发行版" class="headerlink" title="2.GNU/Linux衍生的发行版"></a>2.GNU/Linux衍生的发行版</h2><p>当然，Linux内核和GNU合起来也还不够，对于用户的使用，还应包含命令行Shell或桌面环境（KDE、GNOME、Unity等），所以就衍生出来很多的Linux发行版，主要有三大分支：</p><ul><li>redhat</li><li>debian</li><li>openSUSE</li></ul><p><img src="//night-zhang.github.io/2019/07/26/Linux简介/2019-07-26-16-47-55.png" alt="2019-07-26-16-47-55.png"></p><p>这些发行版如果按应用场景来分，主要有两类：</p><ul><li>以命令行Shell为主的服务器发行版：CentOS/RHEL、openSUSE、Ubuntu Server</li><li>以桌面环境为主的桌面发行版：Ubuntu、Linux Mint、Fedora<h2 id="3-嵌入式Linux"><a href="#3-嵌入式Linux" class="headerlink" title="3. 嵌入式Linux"></a>3. 嵌入式Linux</h2>标准Linux运行在通用计算机上或者云端，虽然包含了很多功能，但是需要的硬件配置较高，如图是Ubuntu 18.04.2 LTS发行版需要的系统要求：<br><img src="//night-zhang.github.io/2019/07/26/Linux简介/2019-07-26-16-48-18.png" alt="2019-07-26-16-48-18.png"><br>在资源极其有限的嵌入式系统中，显然这样的性能是绝对不可能满足的，那么，如何使强大的Linux内核应用在嵌入式系统中呢？</li></ul><p>嵌入式系统有一个非常鲜明的特点 —— 通常都是针对某一个具体应用，所以将标准的Linux根据情况进行裁剪，只保留需要的功能（比如路由器中运行的Linux就不需要界面功能），因此只需要少量的Flash和RAM就可以完美的运行在嵌入式设备中。</p><h2 id="4-嵌入式Linux知识架构"><a href="#4-嵌入式Linux知识架构" class="headerlink" title="4.嵌入式Linux知识架构"></a>4.嵌入式Linux知识架构</h2><p><img src="//night-zhang.github.io/2019/07/26/Linux简介/2019-07-26-16-47-16.png" alt="2019-07-26-16-47-16.png"></p><h2 id="5-如何学Linux"><a href="#5-如何学Linux" class="headerlink" title="5.如何学Linux"></a>5.如何学Linux</h2><p>如此强大有效的一个操作系统，仅作学习之用的话选择其中一个自己喜欢的发行版就好，我的学习旅程是：</p><p>首先在虚拟机上学习：</p><ul><li><p>会操作：基本Linux命令，Linux文件系统</p></li><li><p>会编程：shell脚本编程，基本C编程，网络编程，GUI编程<br>然后在开发板上学习，选用ARM9或ARM11：</p></li><li><p>会启动：移植并成功启动</p></li><li><p>会驱动：可以编写常见驱动程序</p></li></ul><hr><p>作者：Mculover666<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/Mculover666/article/details/87558456" target="_blank" rel="noopener">https://blog.csdn.net/Mculover666/article/details/87558456</a> </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>名词解释(持续更新)</title>
      <link href="/2019/07/25/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/2019/07/25/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e5%a3%b0%e6%98%8e"><strong>声明</strong></a></li><li><a href="#python-egginfo"><strong>Python egg_info</strong></a></li><li><a href="#plc"><strong>PLC</strong></a></li><li><a href="#xxe%e6%bc%8f%e6%b4%9e"><strong>XXE漏洞</strong></a></li><li><a href="#rop%e7%b3%bb%e7%bb%9f%e6%94%bb%e5%87%bb"><strong>ROP系统攻击</strong></a></li><li><a href="#poc"><strong>POC</strong></a></li><li><a href="#cwe"><strong>CWE</strong></a></li><li><a href="#cve"><strong>CVE</strong></a></li><li><a href="#elf%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f"><strong>ELF（文件格式）</strong></a></li><li><a href="#%e6%95%b0%e5%ad%a6%e7%ac%a6%e5%8f%b7%e2%85%a1"><strong>数学符号Ⅱ()</strong></a></li><li><a href="#%e7%89%a9%e8%81%94%e7%bd%91"><strong>物联网</strong></a></li><li><a href="#oss-%e6%93%8d%e4%bd%9c%e6%94%af%e6%8c%81%e5%ad%90%e7%b3%bb%e7%bb%9f"><strong>OSS （操作支持子系统）</strong></a></li><li><a href="#endian"><strong>Endian</strong></a></li><li><a href="#bss%e7%ab%af"><strong>BSS端</strong></a><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a><strong>声明</strong></h1>本文仅为个人日常遇到的专用名次的记录</li></ul><h1 id="Python-egg-info"><a href="#Python-egg-info" class="headerlink" title="Python egg_info"></a><strong>Python egg_info</strong></h1><p>python 中的egg文件:类似于Java 中的jar 包，把一系列的python源码文件、元数据文件、其他资源文件 zip 压缩，重新命名为.egg 文件，目的是作为一个整体进行发布。</p><p><a href="https://stackoverflow.com/questions/2051192/what-is-a-python-egg" target="_blank" rel="noopener">https://stackoverflow.com/questions/2051192/what-is-a-python-egg</a></p><p><a href="https://packaging.python.org/discussions/wheel-vs-egg/" target="_blank" rel="noopener">https://packaging.python.org/discussions/wheel-vs-egg/</a></p><h1 id="PLC"><a href="#PLC" class="headerlink" title="PLC"></a><strong>PLC</strong></h1><p>PLC控制系统，Programmable Logic Controller，可编程逻辑控制器，专为工业生产设计的一种数字运算操作的电子装置，它采用一类可编程的存储器，用于其内部存储程序，执行逻辑运算，顺序控制，定时，计数与算术操作等面向用户的指令，并通过数字或模拟式输入/输出控制各种类型的机械或生产过程。是工业控制的核心部分。</p><h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a><strong>XXE漏洞</strong></h1><p>XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数据进行处理时引发的安全问题</p><h1 id="ROP系统攻击"><a href="#ROP系统攻击" class="headerlink" title="ROP系统攻击"></a><strong>ROP系统攻击</strong></h1><p>ROP全称为Return-oriented Programming（面向返回的编程）是一种新型的基于代码复用技术的攻击，攻击者从已有的库或可执行文件中提取指令片段，构建恶意代码。</p><p>ROP攻击同缓冲区溢出攻击，格式化字符串漏洞攻击不同，是一种全新的攻击方式,它利用代码复用技术。</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a><strong>POC</strong></h1><p>概念验证（Proof of concept，简称POC）是对某些想法的一个不完整的实现，以证明其可行性，示范其原理，其目的是为了验证一些概念或理论。在计算机安全术语中，概念验证经常被用来作为0day、exploit的别名。（通常指并没有充分利用这个漏洞的exploit）</p><p>黑客圈中POC指观点验证程序</p><h1 id="CWE"><a href="#CWE" class="headerlink" title="CWE"></a><strong>CWE</strong></h1><p>CWE:Common Weakness Enumeration<br>CWE常见缺陷列表(Common Weakness Enumeration)是MITRE公司（一个非盈利机构）继CVE（Common Vulnerabilities and Exposures）之后的又一个安全漏洞词典。</p><h1 id="CVE"><a href="#CVE" class="headerlink" title="CVE"></a><strong>CVE</strong></h1><p>CVE 的英文全称是“Common Vulnerabilities &amp; Exposures”公共漏洞和暴露。CVE就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。</p><h1 id="ELF（文件格式）"><a href="#ELF（文件格式）" class="headerlink" title="ELF（文件格式）"></a><strong>ELF（文件格式）</strong></h1><blockquote><p>在计算机科学中，是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。</p></blockquote><p>Unix及类Unix系统下可执行文件、共享库等二进制文件标准格式</p><h1 id="数学符号Ⅱ"><a href="#数学符号Ⅱ" class="headerlink" title="数学符号Ⅱ()"></a><strong>数学符号Ⅱ()</strong></h1><p>示性函数：表示当括号内条件成立时取值为1，否则为0.</p><h1 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a><strong>物联网</strong></h1><p>物联网（The Internet of Things，简称IOT）是指通过 各种信息传感器、射频识别技术、全球定位系统、红外感应器、激光扫描器等各种装置与技术，实时采集任何需要监控、 连接、互动的物体或过程，采集其声、光、热、电、力学、化 学、生物、位置等各种需要的信息，通过各类可能的网络接入，实现物与物、物与人的泛在连接，实现对物品和过程的智能化感知、识别和管理。物联网是一个基于互联网、传统电信网等的信息承载体，它让所有能够被独立寻址的普通物理对象形成互联互通的网络。</p><p><em>采集所有事物相关信息 → 网络接入 → 实现万物互联</em></p><h1 id="OSS-（操作支持子系统）"><a href="#OSS-（操作支持子系统）" class="headerlink" title="OSS （操作支持子系统）"></a><strong>OSS （操作支持子系统）</strong></h1><blockquote><p>OSS是一种操作支持子系统。操作支持子系统（OSS）需完成许多任务，包括移动用户管理、移动设备管理以及网路操作和维护。</p></blockquote><h1 id="Endian"><a href="#Endian" class="headerlink" title="Endian"></a><strong>Endian</strong></h1><blockquote><p>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序。</p></blockquote><blockquote><p>最常见的有两种：<br>1． Little-endian：将低序字节存储在起始地址（低位编址）<br>2． Big-endian：将高序字节存储在起始地址（高位编址）</p></blockquote><blockquote><p>LE（little-endian）：<br>最符合人的思维的字节序：地址低位存储值的低位，地址高位存储值的高位。<br>怎么讲是最符合人的思维的字节序，是因为从人的第一观感来说：低位值小，就应该放在内存地址小的地方，也即内存地址低位；反之，高位值就应该放在内存地址大的地方，也即内存地址高位</p></blockquote><blockquote><p>BE（big-endian）：<br>最直观的字节序：地址低位存储值的高位，地址高位存储值的低位。<br>为什么说直观，不要考虑对应关系：只需要把内存地址从左到右按照由低到高的顺序写出，把值按照通常的高位到低位的顺序写出；两者对照，一个字节一个字节的填充进去</p></blockquote><p>例子：如果我们将0x1234abcd写入到以0x0000开始的内存中，则结果为<br>| 内存   | big-endian | little-endian |<br>| —— | ———- | ————- |<br>| 0x0000 | 0x12       | 0xcd          |<br>| 0x0001 | 0x34       | 0xab          |<br>| 0x0002 | 0xab       | 0x34          |<br>| 0x0003 | 0xcd       | 0x12          |</p><p>x86系列的CPU都是little-endian的字节序。</p><h1 id="BSS端"><a href="#BSS端" class="headerlink" title="BSS端"></a><strong>BSS端</strong></h1><blockquote><p>BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的<strong>全局变量和静态变量</strong>的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。</p></blockquote><ul><li>存放全局、静态变量</li><li>执行之前为0</li></ul><blockquote><p>扩展：可执行程序包括BSS段、数据段（data段）、代码段（也称文本段text段）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VxWorks操作系统简介</title>
      <link href="/2019/07/25/vxworks/"/>
      <url>/2019/07/25/vxworks/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近期在做固件分析的相关知识，由于不明白VxWorks系统不了解，所以想先从正向了解一下系统的基础知识再进行逆向分析。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>VxWorks 是美国 Wind River System 公司（ 简称风河 公司 ，即 WRS 公司）推出的一个==实时操作系统==。</p></blockquote><blockquote><p>VxWorks操作系统由以下5部分构成：板级支持包BSP、微内核wind、网络系统、文件系统以及I/O系统</p></blockquote><blockquote><p>实时多任务操作系统是能在确定的时间内执行其功能，并对外部的异步事件作出响应的计算机系统</p></blockquote><h1 id="BSP"><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><blockquote><p>BSP(Borad Support Packet),板级支持包对单板的硬件功能提供了统一的==软件接口==，它包括硬件初始化、中断的产生和处理、硬件时钟和计时器管理、内存地址映射、内存分配等等。每个板级支持包括一个 ROM 启动（Boot ROM）或其它启动机制。<br>板级支持包（BSP）（Board Support Package）是介于主板硬件和操作系统中驱动层程序之间的一层，一般认为它属于操作系统一部分，主要是实现对操作系统的支持，==为上层的驱动程序提供访问硬件设备寄存器的函数包==，使之能够更好的运行于硬件主板。在嵌入式系统软件的组成中，就有BSP。BSP是相对于操作系统而言的，不同的操作系统对应于不同定义形式的BSP,例如VxWorks的BSP和Linux的BSP相对于某一CPU来说尽管实现的功能一样，可是写法和接口定义是完全不同的，所以写BSP一定要按照该系统BSP的定义形式来写（BSP的编程过程大多数是在某一个成型的BSP模板上进行修改）。这样才能与上层OS保持正确的接口，良好的支持上层OS。 ——百度百科</p></blockquote><p><strong>也就是说，可以简单的理解为操作系统用来操作硬件的工具包</strong></p><p><img src="//night-zhang.github.io/2019/07/25/vxworks/2019-07-25-10-52-33.png" alt="2019-07-25-10-52-33.png"></p><p>oss：此处应该为开源软件的意思</p><h2 id="VxWorks中的BPS"><a href="#VxWorks中的BPS" class="headerlink" title="VxWorks中的BPS"></a>VxWorks中的BPS</h2><blockquote><p>最小系统BSP：包含了CPU系统的初始化程序以及网口，串口，系统时钟等设备的驱动程序。</p></blockquote><blockquote><p>针对某类CPU的硬件单板，VxWorks通常提供有其DEMO板的BSP,也就是我们所说的最小系统BSP。</p></blockquote><blockquote><p>一般来说，我们在硬件系统设计好之后，都会先找到一个与自己系统相近的DEMO板BSP,并以此为基础,开发自己单板的BSP。</p></blockquote><blockquote><p>VxWorks为了最大限度的支持不同的硬件环境，也提供了一些常用硬件芯片的驱动程序，它们通常是与具体CPU无关的设备，如一些PCI网口芯片，串口芯片等。这些驱动程序大多实现为CPU无关或很容易移植，可以方便的用于其他CPU平台。这也是开发驱动程序所应该遵循的原理。另外，我们的最小系统BSP,往往在==默认情况下，使用这些驱动程序==。</p></blockquote><p><strong>也就是说我们做的VxWorks开发就是BSP的开发？</strong></p><h3 id="BSP功能"><a href="#BSP功能" class="headerlink" title="BSP功能"></a>BSP功能</h3><ul><li>给VxWorks提供硬件环境接口</li><li>BSP 主要负责:硬件上电初始化；支持 VxWorks访问硬件驱动；把硬件相关和无关的软件很好地结合到VxWorks。</li><li>BSP不是硬件驱动程序 :是一种访问硬件的硬件驱动程序；硬件驱动分为通用和BSP有关两类；通用驱动管理可在目标环境间移动的设备 (如以太网芯片)；BSP 驱动管理特定目标环境的设备 (如中断控制器）。<br>BSP与VxWorks的关系：<br><img src="//night-zhang.github.io/2019/07/25/vxworks/2019-07-25-11-22-34.png" alt="2019-07-25-11-22-34.png"></li></ul><p><strong>BSP用来调硬件驱动的驱动</strong></p><h2 id="BootRom"><a href="#BootRom" class="headerlink" title="BootRom"></a>BootRom</h2><blockquote><p>VxWorks借鉴了传统PC操作系统的引导原理，其将整个引导过程分为两个阶段：1、BOOTROM启动2、通过BOOTROM加载VxWorks映象</p></blockquote><blockquote><p>BOOTROM相当于PC机中的BIOS，它完成对加载过程中所需设备的初始化及驱动；然后通过某种可选择的通讯手段（如网口，串口），将VxWorks内核映象到内存中，并执行。此处的VxWorks映象就相当于我们在PC机上装的操作系统，如DOS,Windows。</p></blockquote><blockquote><p>BOOTROM和VxWorks使用不同方法来编译生成。<br><strong>BootRom用来初始化设备和驱动，然后加载VxWorks内核</strong></p></blockquote><h1 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h1><blockquote><p>Tornado 是WRS 公司推出的一套实时操作系统开发环境，提供了丰富的调试、仿真环境和工具。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 固件分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VxWorks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常笔记(持续更新)</title>
      <link href="/2019/07/24/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/24/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%e5%a3%b0%e6%98%8e"><strong>声明</strong></a></li><li><a href="#cmd%e4%b8%80%e8%a1%8c%e6%89%a7%e8%a1%8c%e5%a4%9a%e6%9d%a1%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8%e8%bf%9e%e6%8e%a5"><strong>cmd一行执行多条命令使用<code>&amp;</code>连接</strong></a></li><li><a href="#fatal-error-in-launcher-unable-to-create-process-using-%22epython37pythonexe%22-%22epython37scriptspip3exe%22-list"><strong>Fatal error in launcher: Unable to create process using ‘“e:\python37\python.exe” “E:\python37\Scripts\pip3.exe” list’</strong></a></li><li><a href="#import-tensorflow%e5%87%ba%e9%94%99"><strong>import tensorflow出错</strong></a></li><li><a href="#vmware%e6%8b%89%e4%bc%b8%e5%8f%98%e7%b3%8a%e5%88%86%e8%be%a8%e7%8e%87%e4%b8%8d%e5%8f%98"><strong>VMware拉伸变糊(分辨率不变)</strong></a></li><li><a href="#%e6%90%ad%e5%bb%bawin10-tensorflow-gpu%e7%8e%af%e5%a2%83%e6%97%b6%e6%b3%a8%e6%84%8f%e9%a1%ba%e5%ba%8f"><strong>搭建win10 tensorflow-gpu环境时注意顺序</strong></a></li><li><a href="#npm%e5%ae%89%e8%a3%85%e6%8f%90%e9%86%92audit"><strong>npm安装提醒audit</strong></a></li><li><a href="#pycharm%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f%e7%8e%af%e5%a2%83%e5%87%ba%e9%94%99"><strong>pycharm创建虚拟环境出错</strong></a></li><li><a href="#anaconda%e5%ae%89%e8%a3%85%e7%9a%84%e6%97%b6%e5%80%99%e5%8d%83%e4%b8%87%e4%b8%8d%e8%a6%81%e5%85%b3%e9%97%ad%e5%bc%b9%e5%87%ba%e6%9d%a5%e7%9a%84%e5%91%bd%e4%bb%a4%e8%a1%8c"><strong>Anaconda安装的时候千万不要关闭弹出来的命令行</strong></a></li></ul><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a><strong>声明</strong></h1><p>本文没什么技术含量，仅仅作为个人遇到坑之后的记录与反思</p><h1 id="cmd一行执行多条命令使用-amp-连接"><a href="#cmd一行执行多条命令使用-amp-连接" class="headerlink" title="cmd一行执行多条命令使用&amp;连接"></a><strong>cmd一行执行多条命令使用<code>&amp;</code>连接</strong></h1><h1 id="Fatal-error-in-launcher-Unable-to-create-process-using-‘“e-python37-python-exe”-“E-python37-Scripts-pip3-exe”-list’"><a href="#Fatal-error-in-launcher-Unable-to-create-process-using-‘“e-python37-python-exe”-“E-python37-Scripts-pip3-exe”-list’" class="headerlink" title="Fatal error in launcher: Unable to create process using ‘“e:\python37\python.exe”  “E:\python37\Scripts\pip3.exe” list’"></a><strong>Fatal error in launcher: Unable to create process using ‘“e:\python37\python.exe”  “E:\python37\Scripts\pip3.exe” list’</strong></h1><p>pip使用报错，更新pip即可<br><img src="//night-zhang.github.io/2019/07/24/日常笔记/2019-08-02-14-17-20.png" alt="Unable to create process using"></p><h1 id="import-tensorflow出错"><a href="#import-tensorflow出错" class="headerlink" title="import tensorflow出错"></a><strong>import tensorflow出错</strong></h1><p><img src="//night-zhang.github.io/2019/07/24/日常笔记/2019-07-29-20-03-00.png" alt="numpy版本兼容问题"><br>tensorflow 对numpy1.17存在部分兼容性问题，版本小于1.17即可：<code>python -m pip install --upgrade numpy==1.16.4</code></p><p><a href="https://github.com/tensorflow/tensorflow/issues/30427" target="_blank" rel="noopener">参考</a></p><h1 id="VMware拉伸变糊-分辨率不变"><a href="#VMware拉伸变糊-分辨率不变" class="headerlink" title="VMware拉伸变糊(分辨率不变)"></a><strong>VMware拉伸变糊(分辨率不变)</strong></h1><p><code>编辑 → 首选项 → 自动适应 → 自动适应客户机 / 全屏 → 自动适应客户机</code></p><h1 id="搭建win10-tensorflow-gpu环境时注意顺序"><a href="#搭建win10-tensorflow-gpu环境时注意顺序" class="headerlink" title="搭建win10 tensorflow-gpu环境时注意顺序"></a><strong>搭建win10 tensorflow-gpu环境时注意顺序</strong></h1><p>大部分教程都是教你：</p><ul><li>1、先下python某版本（eg.3.5）<code>conda create -n tensorflow-gpu python=3.5</code></li><li>2、再下某版本cuda以及对应版本cudnn</li><li>3、再下tensorflow-gpu<code>pip install --ignore-installed --upgrade tensorflow-gpu==1.9.0</code></li></ul><p>由于教程都是会越来越旧，所以安装的tensorflow可能需要的gpu版本不对<br><img src="//night-zhang.github.io/2019/07/24/日常笔记/2019-07-27-10-37-51.png" alt="gpu版本不对"><br>所以最好是132的顺序</p><p><em>别费事,cuda9.0对应tensorflow1.9;cuda10.0对应tensorflow1.14</em></p><p>查看虚拟环境<code>conda info --envs</code></p><h1 id="npm安装提醒audit"><a href="#npm安装提醒audit" class="headerlink" title="npm安装提醒audit"></a><strong>npm安装提醒audit</strong></h1><p><img src="//night-zhang.github.io/2019/07/24/日常笔记/2019-07-25-22-31-11.png" alt="2019-07-25-22-31-11.png"><br>此处版本不合理问题，如果按照提示执行<code>npm audit</code>相关指令还是没效果，可以不用理会，不影响正常使用</p><p><em>注意仔细看字，别因为是英文就一目十行，当时遇到这个问题其实不是问题，结果没出现只是因为别的地方开关没开，要专心</em></p><h1 id="pycharm创建虚拟环境出错"><a href="#pycharm创建虚拟环境出错" class="headerlink" title="pycharm创建虚拟环境出错"></a><strong>pycharm创建虚拟环境出错</strong></h1><p>用anaconda3创建虚拟环境出错，改用2，或者手动下载python3的纯净包</p><p><img src="//night-zhang.github.io/2019/07/24/日常笔记/1563780832508.png" alt="1563780832508"></p><p><img src="//night-zhang.github.io/2019/07/24/日常笔记/1563780797384.png" alt="1563780797384"></p><p><em>似乎是anaconda3包的问题，重装电脑之后尽量不要两个anaconda版本一起使用</em></p><h1 id="Anaconda安装的时候千万不要关闭弹出来的命令行"><a href="#Anaconda安装的时候千万不要关闭弹出来的命令行" class="headerlink" title="Anaconda安装的时候千万不要关闭弹出来的命令行"></a><strong>Anaconda安装的时候千万不要关闭弹出来的命令行</strong></h1><p>弹出来的命令行是在安装相关的组件，不然conda什么的都会没有。。。</p><p><em>做动作之前要考虑一下，别随便乱点</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
